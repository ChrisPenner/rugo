<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Go</title>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Prevent zoom on double tap in iOS */
            touch-action: manipulation;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            padding: 15px 5px 5px 5px;
            gap: 5px;
        }

        /* Main game area - takes most of the space */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
            /* Important for flex sizing */
        }

        /* Responsive canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: min(95vmin, 90vw);
            max-height: min(95vmin, 90vw);
            aspect-ratio: 1;
        }

        #game-canvas {
            border: 2px solid #8B4513;
            background-color: #DEB887;
            cursor: pointer;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
            /* Prevent canvas selection on mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Mobile magnifier for precise placement */
        .magnifier {
            position: fixed;
            width: 120px;
            height: 120px;
            border: 3px solid #333;
            border-radius: 60px;
            background: white;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .magnifier canvas {
            width: 100%;
            height: 100%;
            border-radius: 57px;
        }

        /* Compact game status under the board */
        .game-status {
            margin-top: 8px;
            text-align: center;
            font-size: 14px;
        }

        .game-status #current-player {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        .game-status #score-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .game-status #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .controls {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 5px;
            max-height: 25vh;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 12px;
            color: #666;
        }

        .board-size-controls select {
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-width: 80px;
            min-height: 32px;
        }

        /* Primary button controls container - for most used actions */
        .primary-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
        }

        .primary-controls button {
            padding: 12px 16px;
            font-size: 16px;
            font-weight: 700;
            min-height: 44px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Secondary controls container - for less frequently used actions */
        .secondary-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .secondary-button-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 6px;
            align-items: center;
        }

        /* Single button row for actions like sound toggle */
        .secondary-button-row:has(button:only-child),
        .single-button-row {
            grid-template-columns: 1fr;
            justify-items: center;
        }

        .tertiary-button-row {
            display: grid;
            grid-template-columns: auto auto auto;
            gap: 6px;
            align-items: center;
        }


        .secondary-button-row select {
            padding: 8px 10px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-height: 36px;
            text-align: center;
        }

        .secondary-controls button {
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 36px;
            background-color: #6c757d;
            opacity: 0.85;
        }

        .secondary-controls button:hover {
            background-color: #5a6268;
            opacity: 1;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 14px;
            color: #666;
        }

        .board-size-controls select {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: white;
            min-width: 100px;
            min-height: 36px;
        }

        button {
            padding: 15px 20px;
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            /* Improve touch targets */
            min-height: 48px;
            min-width: 120px;
            /* Prevent button text selection */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Add touch feedback */
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            background-color: #3d8b40;
        }

        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            background-color: #cccccc;
            transform: none;
        }



        #current-player {
            font-size: 14px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        #score-display {
            display: flex;
            justify-content: space-around;
            margin-top: 6px;
            flex-wrap: wrap;
            gap: 8px;
        }

        #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        /* Mobile and tablet optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 20px 3px 3px 3px;
                gap: 3px;
            }

            .game-area {
                margin-top: 10px;
            }

            .canvas-container {
                max-width: min(92vmin, 95vw);
                max-height: min(92vmin, 95vw);
            }

            .primary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 40px;
            }

            .secondary-controls {
                padding: 6px;
                gap: 4px;
            }

            .secondary-controls button {
                padding: 6px 8px;
                font-size: 12px;
                min-height: 32px;
            }

            .board-size-controls select {
                min-width: 70px;
                min-height: 28px;
                font-size: 11px;
            }

            #current-player {
                font-size: 12px;
                margin: 2px 0;
            }

            #score-display div {
                padding: 3px 6px;
                font-size: 11px;
                min-width: 80px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .container {
                padding: 15px 2px 2px 2px;
                gap: 2px;
            }

            .game-area {
                margin-top: 8px;
            }

            .primary-controls {
                gap: 4px;
            }

            .primary-controls button {
                padding: 8px 10px;
                font-size: 13px;
                min-height: 36px;
            }

            .secondary-controls {
                padding: 4px;
                gap: 3px;
            }

            .secondary-button-row {
                grid-template-columns: 1fr;
                gap: 3px;
            }

            .secondary-controls button {
                padding: 5px 6px;
                font-size: 11px;
                min-height: 28px;
            }

            #score-display {
                flex-direction: column;
                gap: 4px;
            }
        }

        /* Wide screen layout (desktop/landscape tablets) - side-by-side layout */
        @media (min-aspect-ratio: 4/3) and (min-width: 768px) {
            .container {
                flex-direction: row;
                padding: 8px;
                gap: 16px;
                align-items: center;
            }

            .game-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .canvas-container {
                width: 100%;
                height: 100%;
                max-width: min(85vh, calc(100vw - 250px));
                max-height: min(85vh, calc(100vw - 250px));
            }

            .controls {
                flex-shrink: 0;
                width: auto;
                min-width: 220px;
                max-height: 85vh;
                gap: 12px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                overflow-y: auto;
                padding: 8px;
            }

            .primary-controls {
                gap: 12px;
            }

            .primary-controls button {
                padding: 14px 18px;
                font-size: 16px;
                min-height: 48px;
                min-width: auto;
                width: 100%;
                white-space: nowrap;
            }

            .secondary-controls {
                padding: 12px;
                gap: 8px;
            }

            .secondary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 38px;
                min-width: auto;
                white-space: nowrap;
            }

            .secondary-button-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                gap: 8px;
                align-items: center;
            }

            .secondary-button-row select {
                padding: 10px 12px;
                font-size: 14px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background-color: white;
                min-height: 38px;
            }

            .secondary-button-row button {
                flex: 1;
            }

            #current-player {
                font-size: 15px;
                margin: 6px 0;
            }

            #score-display {
                flex-direction: row;
                gap: 10px;
            }

            #score-display div {
                padding: 6px 10px;
                font-size: 13px;
                min-width: 120px;
            }
        }

        /* Mobile landscape (smaller screens) - compact horizontal layout */
        @media (max-height: 600px) and (orientation: landscape) and (max-width: 767px) {
            .container {
                flex-direction: row;
                padding: 3px;
                gap: 8px;
            }

            .game-area {
                flex: 1;
            }

            .controls {
                flex-shrink: 0;
                width: 200px;
                max-height: none;
                margin-top: 8px;
            }




        }
    </style>
</head>

<body>
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="game-canvas" width="600" height="600"></canvas>
                <div class="magnifier" id="magnifier">
                    <canvas id="magnifier-canvas" width="120" height="120"></canvas>
                </div>
            </div>
            <!-- Compact game status directly under the board -->
            <div class="game-status">
                <div id="current-player">Current Player: Black</div>
                <div id="score-display">
                    <div>Black Captures: <span id="black-score">0</span></div>
                    <div>White Captures: <span id="white-score">0</span></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <!-- Primary game controls - most frequently used -->
            <div class="primary-controls">
                <button id="undo-btn" disabled>Undo</button>
                <button id="redo-btn" disabled>Redo</button>
                <button id="pass-btn">Pass</button>
            </div>

            <!-- Secondary controls - less frequently used -->
            <div class="secondary-controls">
                <div class="secondary-button-row">
                    <button id="new-game-btn">Clear Board</button>
                    <select id="board-size">
                        <option value="9">9×9</option>
                        <option value="13">13×13</option>
                        <option value="19" selected>19×19</option>
                    </select>
                    <button id="copy-url-btn">Copy Game State</button>
                </div>
                <div class="tertiary-button-row">
                    <button id="sound-toggle-btn">🔊 Sound: ON</button>
                    <button id="wake-lock-btn">💡 Prevent sleep: OFF</button>
                    <button id="edit-mode-btn">✏️ Edit Mode: OFF</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { GoGame } from './pkg/rugo.js';

        let game = null;
        const canvas = document.getElementById('game-canvas');
        const currentPlayerText = document.getElementById('current-player');
        let suppressUrlUpdate = false; // Flag to prevent infinite loops
        let eventListenersSetup = false; // Flag to prevent duplicate event listeners
        let hoverPosition = null; // Track mouse position for hover preview
        let editMode = false; // Track whether we're in edit mode
        let isDragging = false; // Track if we're currently dragging in edit mode
        let dragState = null; // The state to apply while dragging (0, 1, or 2)

        // Sound system for game audio feedback
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.volume = 0.3; // Keep sounds subtle
                this.initAudioContext();
            }

            async initAudioContext() {
                try {
                    // Create audio context on first user interaction
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Resume context if it's suspended (required for some browsers)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                } catch (error) {
                    console.warn('Audio not supported:', error);
                    this.enabled = false;
                }
            }

            async ensureAudioContext() {
                if (!this.audioContext) {
                    await this.initAudioContext();
                }
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            // Create a bright, sharp tap sound like stone on wood with subtle randomness
            async playTapSound() {
                if (!this.enabled || !this.audioContext) return;

                try {
                    await this.ensureAudioContext();

                    // Add subtle randomness for natural variation
                    const randomVariation = () => 0.85 + Math.random() * 0.3; // ±15% variation
                    const pitchVariation = () => 0.9 + Math.random() * 0.2; // ±10% pitch variation
                    const timingVariation = () => 0.8 + Math.random() * 0.4; // ±20% timing variation

                    // Create multiple oscillators for a rich, full-spectrum sound
                    const oscillator1 = this.audioContext.createOscillator(); // Primary mid-range
                    const oscillator2 = this.audioContext.createOscillator(); // High harmonic
                    const oscillator3 = this.audioContext.createOscillator(); // Low body
                    const gainNode1 = this.audioContext.createGain();
                    const gainNode2 = this.audioContext.createGain();
                    const gainNode3 = this.audioContext.createGain();
                    const masterGain = this.audioContext.createGain();

                    // Connect nodes
                    oscillator1.connect(gainNode1);
                    oscillator2.connect(gainNode2);
                    oscillator3.connect(gainNode3);
                    gainNode1.connect(masterGain);
                    gainNode2.connect(masterGain);
                    gainNode3.connect(masterGain);
                    masterGain.connect(this.audioContext.destination);

                    // Primary tap sound with slight pitch variation
                    const baseFreq1 = 1200 * pitchVariation();
                    const endFreq1 = 400 * pitchVariation();
                    oscillator1.frequency.setValueAtTime(baseFreq1, this.audioContext.currentTime);
                    oscillator1.frequency.exponentialRampToValueAtTime(endFreq1, this.audioContext.currentTime + 0.008 * timingVariation());

                    // Secondary harmonic with variation
                    const baseFreq2 = 2400 * pitchVariation();
                    const endFreq2 = 800 * pitchVariation();
                    oscillator2.frequency.setValueAtTime(baseFreq2, this.audioContext.currentTime);
                    oscillator2.frequency.exponentialRampToValueAtTime(endFreq2, this.audioContext.currentTime + 0.005 * timingVariation());

                    // Low frequency component with variation
                    const baseFreq3 = 200 * pitchVariation();
                    const endFreq3 = 80 * pitchVariation();
                    oscillator3.frequency.setValueAtTime(baseFreq3, this.audioContext.currentTime);
                    oscillator3.frequency.exponentialRampToValueAtTime(endFreq3, this.audioContext.currentTime + 0.012 * timingVariation());

                    // Sharp attack envelope for primary sound with volume variation
                    gainNode1.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode1.gain.linearRampToValueAtTime(this.volume * 0.8 * randomVariation(), this.audioContext.currentTime + 0.0005 * timingVariation());
                    gainNode1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.04 * timingVariation());

                    // Brighter harmonic with variation
                    gainNode2.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode2.gain.linearRampToValueAtTime(this.volume * 0.4 * randomVariation(), this.audioContext.currentTime + 0.0003 * timingVariation());
                    gainNode2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.02 * timingVariation());

                    // Low frequency body with variation
                    gainNode3.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode3.gain.linearRampToValueAtTime(this.volume * 0.3 * randomVariation(), this.audioContext.currentTime + 0.001 * timingVariation());
                    gainNode3.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.035 * timingVariation());

                    // Master volume control with slight variation
                    masterGain.gain.setValueAtTime(this.volume * randomVariation(), this.audioContext.currentTime);

                    // Play the sound with randomized durations
                    const duration1 = 0.04 * timingVariation();
                    const duration2 = 0.02 * timingVariation();
                    const duration3 = 0.035 * timingVariation();

                    oscillator1.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + duration1);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator2.stop(this.audioContext.currentTime + duration2);
                    oscillator3.start(this.audioContext.currentTime);
                    oscillator3.stop(this.audioContext.currentTime + duration3);

                } catch (error) {
                    console.warn('Error playing sound:', error);
                }
            }

            // Toggle sound on/off
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }

            // Set volume (0.0 to 1.0)
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }
        }

        // Wake lock system to prevent screen from dimming/sleeping
        class WakeLockSystem {
            constructor() {
                this.wakeLock = null;
                this.enabled = false;
                this.supported = 'wakeLock' in navigator;

                // Handle visibility change to re-acquire wake lock
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.enabled) {
                        this.requestWakeLock();
                    }
                });
            }

            async requestWakeLock() {
                if (!this.supported) {
                    console.warn('Wake Lock API not supported');
                    return false;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired - screen will stay on');

                    // Listen for wake lock release
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake lock released');
                    });

                    return true;
                } catch (error) {
                    console.warn('Failed to acquire wake lock:', error);
                    return false;
                }
            }

            async releaseWakeLock() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('Wake lock manually released');
                    } catch (error) {
                        console.warn('Error releasing wake lock:', error);
                    }
                }
            }

            async toggle() {
                if (this.enabled) {
                    // Turn off wake lock
                    this.enabled = false;
                    await this.releaseWakeLock();
                    return false;
                } else {
                    // Turn on wake lock
                    this.enabled = true;
                    const success = await this.requestWakeLock();
                    if (!success) {
                        this.enabled = false;
                    }
                    return this.enabled;
                }
            }

            isSupported() {
                return this.supported;
            }

            isEnabled() {
                return this.enabled;
            }
        }

        // Initialize sound system
        const soundSystem = new SoundSystem();

        // Initialize wake lock system
        const wakeLockSystem = new WakeLockSystem();

        // Confirmation preferences stored in localStorage
        const confirmationPrefs = {
            boardSizeChange: 'confirm_board_size_change',
            newGame: 'confirm_new_game',
            editMode: 'confirm_edit_mode'
        };

        // User preference storage keys
        const userPrefs = {
            soundEnabled: 'sound_enabled',
            wakeLockEnabled: 'wake_lock_enabled',
            preferredBoardSize: 'preferred_board_size',
            lastGameState: 'last_game_state'
        };

        // Function to save user preferences to localStorage
        function saveUserPreference(key, value) {
            try {
                localStorage.setItem(key, value.toString());
            } catch (error) {
                console.warn('Failed to save preference:', error);
            }
        }

        // Function to load user preferences from localStorage
        function loadUserPreference(key, defaultValue) {
            try {
                const stored = localStorage.getItem(key);
                if (stored === null) return defaultValue;

                // Handle boolean values
                if (defaultValue === true || defaultValue === false) {
                    return stored === 'true';
                }

                // Handle numeric values
                if (typeof defaultValue === 'number') {
                    const parsed = parseInt(stored, 10);
                    return isNaN(parsed) ? defaultValue : parsed;
                }

                // Handle string values
                return stored;
            } catch (error) {
                console.warn('Failed to load preference:', error);
                return defaultValue;
            }
        }

        // Function to save current game state to localStorage
        function saveGameStateToLocalStorage() {
            if (!game) return;

            try {
                const state = game.serialize_state();
                localStorage.setItem(userPrefs.lastGameState, state);
                console.log('Game state saved to localStorage');
            } catch (error) {
                console.warn('Failed to save game state to localStorage:', error);
            }
        }

        // Function to load game state from localStorage
        function loadGameStateFromLocalStorage() {
            try {
                const state = localStorage.getItem(userPrefs.lastGameState);
                if (state && game) {
                    if (game.deserialize_state(state)) {
                        console.log('Game state restored from localStorage');
                        // Update board size selector to match loaded state
                        const boardSize = game.get_board_size();
                        document.getElementById('board-size').value = boardSize.toString();
                        return true;
                    } else {
                        console.warn('Failed to deserialize game state from localStorage');
                    }
                }
            } catch (error) {
                console.warn('Failed to load game state from localStorage:', error);
            }
            return false;
        }

        // Utility function to show confirmation with "Don't notify me again" option
        function showConfirmationWithOptOut(message, prefKey) {
            // Check if user has opted out of this confirmation
            const skipConfirm = localStorage.getItem(prefKey) === 'false';
            if (skipConfirm) {
                return true; // Always proceed if user opted out
            }

            // Create a custom dialog with checkbox
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: Arial, sans-serif;
            `;

            const dialogBox = document.createElement('div');
            dialogBox.style.cssText = `
                background: white;
                padding: 24px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                min-width: 320px;
                text-align: center;
            `;

            const messageText = document.createElement('p');
            messageText.textContent = message;
            messageText.style.cssText = `
                margin: 0 0 20px 0;
                font-size: 16px;
                line-height: 1.4;
                color: #333;
            `;

            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = `
                margin: 16px 0 20px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = 'dont-notify-again';
            checkbox.style.cssText = `
                margin: 0;
                transform: scale(1.2);
            `;

            const checkboxLabel = document.createElement('label');
            checkboxLabel.htmlFor = 'dont-notify-again';
            checkboxLabel.textContent = "Don't ask me again";
            checkboxLabel.style.cssText = `
                font-size: 14px;
                color: #666;
                cursor: pointer;
                user-select: none;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 12px;
                justify-content: center;
            `;

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background: #f8f9fa;
                color: #333;
                font-size: 14px;
                cursor: pointer;
                min-width: 80px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Continue';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
                background: #4CAF50;
                color: white;
                font-size: 14px;
                cursor: pointer;
                min-width: 80px;
            `;

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(checkboxLabel);
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);
            dialogBox.appendChild(messageText);
            dialogBox.appendChild(checkboxContainer);
            dialogBox.appendChild(buttonContainer);
            dialog.appendChild(dialogBox);
            document.body.appendChild(dialog);

            return new Promise((resolve) => {
                const cleanup = () => {
                    document.body.removeChild(dialog);
                };

                cancelButton.addEventListener('click', () => {
                    if (checkbox.checked) {
                        localStorage.setItem(prefKey, 'false');
                    }
                    cleanup();
                    resolve(false);
                });

                confirmButton.addEventListener('click', () => {
                    if (checkbox.checked) {
                        localStorage.setItem(prefKey, 'false');
                    }
                    cleanup();
                    resolve(true);
                });

                // Close on escape key
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        document.removeEventListener('keydown', handleKeydown);
                        cleanup();
                        resolve(false);
                    }
                };
                document.addEventListener('keydown', handleKeydown);
            });
        }

        // Helper function to get board coordinates from mouse/touch event
        function getBoardPositionFromEvent(event) {
            if (!game) return null;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Handle both touch and mouse events
            if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    return null;
                }
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Calculate coordinates relative to the displayed canvas size
            // Account for device pixel ratio scaling
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            const canvasX = (clientX - rect.left) * (displayWidth / rect.width);
            const canvasY = (clientY - rect.top) * (displayHeight / rect.height);

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Calculate board layout (same as in drawBoard)
            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Convert canvas coordinates to board coordinates
            const boardX = Math.round((canvasX - offsetX) / cellSize);
            const boardY = Math.round((canvasY - offsetY) / cellSize);

            return { x: boardX, y: boardY };
        }

        // Helper function to check if board position is valid for placing a stone
        function isValidBoardPosition(boardX, boardY) {
            if (!game) return false;

            const currentBoardSize = game.get_board_size();

            // Check if position is within board bounds
            if (boardX < 0 || boardX >= currentBoardSize || boardY < 0 || boardY >= currentBoardSize) {
                return false;
            }

            // In edit mode, allow clicking on any position (empty or occupied)
            if (editMode) {
                return true;
            }

            // In normal game mode, check if position is empty
            return game.get_board_state(boardX, boardY) === 0;
        }

        async function initGame() {
            try {
                // Initialize the wasm module
                await init();

                // Restore user preferences
                restoreUserPreferences();

                // Get selected board size
                const boardSize = parseInt(document.getElementById('board-size').value);

                // Set up responsive canvas sizing
                setupResponsiveCanvas();

                // Create game instance with selected size
                game = GoGame.new_with_size(canvas, boardSize);

                // Set up event listeners (only once)
                if (!eventListenersSetup) {
                    setupEventListeners();
                }

                // Try to load state from URL first, then localStorage, otherwise draw fresh board
                if (!loadStateFromUrl()) {
                    if (!loadGameStateFromLocalStorage()) {
                        updateUrl(); // Set initial state in URL only for fresh games
                    } else {
                        // If we loaded from localStorage, update URL to match
                        updateUrl();
                    }
                }
                drawBoard();
                updateUndoRedoButtons();

            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        }

        // Function to restore all user preferences
        function restoreUserPreferences() {
            // Restore board size preference
            const preferredBoardSize = loadUserPreference(userPrefs.preferredBoardSize, 19);
            const boardSizeSelect = document.getElementById('board-size');
            boardSizeSelect.value = preferredBoardSize.toString();

            // Restore sound preference
            const soundEnabled = loadUserPreference(userPrefs.soundEnabled, true);
            soundSystem.enabled = soundEnabled;
            const soundButton = document.getElementById('sound-toggle-btn');
            soundButton.textContent = soundEnabled ? '🔊 Sound: ON' : '🔇 Sound: OFF';

            // Restore wake lock preference
            const wakeLockEnabled = loadUserPreference(userPrefs.wakeLockEnabled, false);
            if (wakeLockEnabled && wakeLockSystem.isSupported()) {
                // Try to enable wake lock on startup
                wakeLockSystem.toggle().then(() => {
                    updateWakeLockButton();
                }).catch(() => {
                    // If it fails, update button to show OFF state
                    updateWakeLockButton();
                });
            } else {
                updateWakeLockButton();
            }
        }

        // Function to update wake lock button text
        function updateWakeLockButton() {
            const button = document.getElementById('wake-lock-btn');
            if (!wakeLockSystem.isSupported()) {
                button.textContent = '❌ Keep Screen On: Not Supported';
                button.disabled = true;
                button.hidden = true;
            } else if (wakeLockSystem.isEnabled()) {
                button.textContent = '💡 Prevent Sleep: ON';
            } else {
                button.textContent = '💡 Prevent Sleep: OFF';
            }
        }

        function setupResponsiveCanvas() {
            const container = document.querySelector('.canvas-container');
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);

            // Get device pixel ratio for high-DPI displays
            const devicePixelRatio = window.devicePixelRatio || 1;

            // Calculate the actual pixel size we want to render at
            const displaySize = Math.floor(size);
            const renderSize = Math.floor(displaySize * devicePixelRatio);

            // Set canvas internal dimensions to high resolution
            canvas.width = renderSize;
            canvas.height = renderSize;

            // Set CSS size to display size
            canvas.style.width = displaySize + 'px';
            canvas.style.height = displaySize + 'px';

            // Scale the context to match device pixel ratio
            const ctx = canvas.getContext('2d');
            ctx.scale(devicePixelRatio, devicePixelRatio);

            console.log(`Canvas setup: Display ${displaySize}px, Render ${renderSize}px, DPR ${devicePixelRatio}`);
        }

        function setupEventListeners() {
            if (eventListenersSetup) return; // Prevent duplicate listeners
            eventListenersSetup = true;

            // Helper function to handle board interactions
            function handleBoardInteraction(event) {
                if (!game) return;

                // Prevent default touch behaviors
                event.preventDefault();

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if click is within board bounds and position is valid
                if (isValidBoardPosition(boardX, boardY)) {
                    try {
                        if (editMode) {
                            // Edit mode: cycle through states (Empty -> Black -> White -> Empty)
                            const currentState = game.get_board_state(boardX, boardY);

                            // Cycle: 0 (Empty) -> 1 (Black) -> 2 (White) -> 0 (Empty)
                            const nextState = (currentState + 1) % 3;

                            console.log(`Edit mode: position (${boardX}, ${boardY}), current state: ${currentState}, next state: ${nextState}`);

                            const result = game.set_board_position(boardX, boardY, nextState);
                            console.log(`Set position result: ${result}`);

                            if (result === "Position set successfully") {
                                // Start dragging with this state
                                isDragging = true;
                                dragState = nextState;

                                // Play sound effect for edit action
                                soundSystem.playTapSound();

                                // Keep hover position to continue showing preview for multiple clicks
                                // hoverPosition remains unchanged so the preview continues to show

                                drawBoard();
                                // Don't update URL here - wait until drag ends
                            } else {
                                console.log('Edit not allowed:', result);
                            }
                        } else {
                            // Normal game mode
                            const result = game.handle_board_click(boardX, boardY);
                            if (result === "Move successful") {
                                // Play sound effect for successful stone placement
                                soundSystem.playTapSound();

                                // Clear hover position after successful move
                                hoverPosition = null;

                                drawBoard();
                                updateUndoRedoButtons();
                                updateUrl();
                            } else {
                                // Log error message
                                console.log('Move not allowed:', result);
                            }
                        }
                    } catch (error) {
                        console.error('Board interaction error:', error);
                    }
                }
            }

            // Helper function to handle dragging in edit mode
            function handleEditDrag(event) {
                if (!game || !editMode || !isDragging || dragState === null) return;

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if position is within board bounds
                if (isValidBoardPosition(boardX, boardY)) {
                    // Only apply the drag state if the current position doesn't already have it
                    const currentState = game.get_board_state(boardX, boardY);
                    if (currentState !== dragState) {
                        const result = game.set_board_position(boardX, boardY, dragState);
                        if (result === "Position set successfully") {
                            drawBoard();
                        }
                    }
                }
            }

            // Canvas mousedown handler for drag start
            canvas.addEventListener('mousedown', (event) => {
                if (editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Canvas mouseup handler for drag end
            canvas.addEventListener('mouseup', (event) => {
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL once at the end of drag

                    // Restore hover position for continued preview
                    const boardPos = getBoardPositionFromEvent(event);
                    if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                        hoverPosition = boardPos;
                        drawBoard(); // Redraw to show the hover preview
                    }
                }
            });

            // Canvas click handler for non-edit mode
            canvas.addEventListener('click', (event) => {
                if (!editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Mouse move handler for hover preview and dragging
            canvas.addEventListener('mousemove', (event) => {
                if (!game) return;

                // Handle dragging in edit mode
                if (editMode && isDragging) {
                    handleEditDrag(event);
                }

                // Handle hover preview
                const boardPos = getBoardPositionFromEvent(event);
                if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                    hoverPosition = boardPos;
                } else {
                    hoverPosition = null;
                }

                // Only redraw for hover if we're not dragging (to avoid excessive redraws)
                if (!isDragging) {
                    drawBoard(); // Redraw to show/hide hover preview
                }
            });

            // Mouse leave handler to clear hover preview and stop dragging
            canvas.addEventListener('mouseleave', () => {
                hoverPosition = null;
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL when drag ends
                }
                drawBoard();
            });

            // Magnifier functionality for mobile touch precision
            const magnifier = document.getElementById('magnifier');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const magnifierCtx = magnifierCanvas.getContext('2d');
            let magnifierScale = 2.0; // Magnification level

            function showMagnifier(touch) {
                // Position the magnifier above the finger
                const magnifierWidth = 120;
                const magnifierHeight = 120;
                const offsetY = magnifierHeight + 30; // Space above finger

                // Get touch position relative to viewport (clientX/Y for absolute positioning)
                let x = touch.clientX - magnifierWidth / 2;
                let y = touch.clientY - offsetY;

                // Keep magnifier within viewport
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                if (x < 10) x = 10;
                if (x + magnifierWidth > viewportWidth - 10) x = viewportWidth - magnifierWidth - 10;
                if (y < 10) y = 10;

                magnifier.style.left = x + 'px';
                magnifier.style.top = y + 'px';
                magnifier.style.display = 'block';

                // Draw magnified content immediately
                drawMagnifierContent(touch);
            } function hideMagnifier() {
                magnifier.style.display = 'none';
            }

            function drawMagnifierContent(touch) {
                const rect = canvas.getBoundingClientRect();

                // Get touch position relative to canvas display size
                const canvasDisplayX = touch.clientX - rect.left;
                const canvasDisplayY = touch.clientY - rect.top;

                // Account for device pixel ratio - canvas internal size vs display size
                const devicePixelRatio = window.devicePixelRatio || 1;
                const canvasX = canvasDisplayX * devicePixelRatio;
                const canvasY = canvasDisplayY * devicePixelRatio;

                // Clear magnifier canvas
                magnifierCtx.clearRect(0, 0, 120, 120);

                // Calculate source area - use display-sized area to get actual size in magnifier
                const displaySourceSize = 120; // 120px in display coordinates
                const canvasSourceSize = displaySourceSize * devicePixelRatio; // Scale up for canvas coordinates
                const sourceX = canvasX - canvasSourceSize / 2;
                const sourceY = canvasY - canvasSourceSize / 2;

                // Save context for clipping
                magnifierCtx.save();

                // Create circular clipping mask
                magnifierCtx.beginPath();
                magnifierCtx.arc(60, 60, 57, 0, 2 * Math.PI);
                magnifierCtx.clip();

                // Draw actual-size portion of main canvas
                magnifierCtx.drawImage(
                    canvas,
                    sourceX, sourceY, canvasSourceSize, canvasSourceSize,  // Source area (canvas coordinates)
                    0, 0, 120, 120                                          // Destination area (display size = actual size)
                );

                // Draw hover preview stone if we're over a valid position
                const boardPos = getBoardPositionFromEvent(touch);
                if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                    // Calculate board layout parameters (same as in drawBoard)
                    const displayWidth = canvas.width / devicePixelRatio;
                    const displayHeight = canvas.height / devicePixelRatio;
                    const currentBoardSize = game.get_board_size();
                    const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
                    const boardPixelSize = cellSize * (currentBoardSize - 1);
                    const offsetX = (displayWidth - boardPixelSize) / 2;
                    const offsetY = (displayHeight - boardPixelSize) / 2;

                    // Calculate stone position in display coordinates
                    const stoneDisplayX = offsetX + boardPos.x * cellSize;
                    const stoneDisplayY = offsetY + boardPos.y * cellSize;

                    // Convert to magnifier coordinates
                    const stoneMagnifierX = stoneDisplayX - canvasDisplayX + 60; // Center at crosshair
                    const stoneMagnifierY = stoneDisplayY - canvasDisplayY + 60;

                    // Only draw if the stone position is within the magnifier view
                    if (stoneMagnifierX >= 0 && stoneMagnifierX <= 120 && stoneMagnifierY >= 0 && stoneMagnifierY <= 120) {
                        const currentPlayer = game.get_current_player();
                        const stoneRadius = Math.max(4, cellSize * 0.45);

                        // Draw stone with transparency to indicate it's a preview
                        magnifierCtx.globalAlpha = 0.7;
                        magnifierCtx.beginPath();
                        magnifierCtx.arc(stoneMagnifierX, stoneMagnifierY, stoneRadius, 0, 2 * Math.PI);

                        if (currentPlayer === 1) { // Black
                            magnifierCtx.fillStyle = '#000';
                            magnifierCtx.fill();
                            magnifierCtx.strokeStyle = '#333';
                        } else { // White
                            magnifierCtx.fillStyle = '#fff';
                            magnifierCtx.fill();
                            magnifierCtx.strokeStyle = '#ccc';
                        }
                        magnifierCtx.lineWidth = 1;
                        magnifierCtx.stroke();
                        magnifierCtx.globalAlpha = 1.0; // Reset alpha
                    }
                }

                // Draw crosshair for precise targeting
                magnifierCtx.restore(); // Restore to draw crosshair outside clipping
                magnifierCtx.strokeStyle = '#ff0000';
                magnifierCtx.lineWidth = 2;
                magnifierCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                magnifierCtx.shadowBlur = 2;
                magnifierCtx.beginPath();
                magnifierCtx.moveTo(60, 45);
                magnifierCtx.lineTo(60, 75);
                magnifierCtx.moveTo(45, 60);
                magnifierCtx.lineTo(75, 60);
                magnifierCtx.stroke();
                magnifierCtx.shadowBlur = 0; // Reset shadow
            }

            // Touch event handlers for better mobile support with drag functionality
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // In edit mode, start dragging immediately
                    handleBoardInteraction(event);
                } else {
                    // Store the touch for potential stone placement in normal mode
                    canvas._touchStartTime = Date.now();
                    canvas._touchStartPos = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };

                    // Show magnifier for precise placement
                    showMagnifier(event.touches[0]);
                }
            });

            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode && isDragging) {
                    // Handle dragging in edit mode
                    handleEditDrag(event);
                } else if (!editMode && canvas._touchStartTime) {
                    // Update magnifier position in normal mode while dragging
                    // Use requestAnimationFrame for smooth updates
                    requestAnimationFrame(() => {
                        showMagnifier(event.touches[0]);
                    });
                }
            });

            canvas.addEventListener('touchend', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // End dragging in edit mode
                    if (isDragging) {
                        isDragging = false;
                        dragState = null;
                        updateUrl(); // Update URL when drag ends

                        // For touch, we don't maintain hover position since there's no persistent cursor
                        // Touch interactions are discrete events
                    }
                } else {
                    // Handle stone placement in normal mode
                    if (canvas._touchStartTime && canvas._touchStartPos) {
                        const touch = event.changedTouches[0];

                        // Always try to place a stone at the final touch position
                        // This creates the "drag to place" behavior
                        const finalBoardPos = getBoardPositionFromEvent(event);
                        if (finalBoardPos && isValidBoardPosition(finalBoardPos.x, finalBoardPos.y)) {
                            try {
                                const result = game.handle_board_click(finalBoardPos.x, finalBoardPos.y);
                                if (result === "Move successful") {
                                    // Play sound effect for successful stone placement
                                    soundSystem.playTapSound();

                                    drawBoard();
                                    updateUndoRedoButtons();
                                    updateUrl();
                                }
                            } catch (error) {
                                console.error('Stone placement error:', error);
                            }
                        }
                    }

                    // Clean up
                    delete canvas._touchStartTime;
                    delete canvas._touchStartPos;
                    hideMagnifier(); // Hide magnifier when touch ends
                }
            });

            // Prevent context menu on touch devices
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            // Board size selector
            document.getElementById('board-size').addEventListener('change', async (event) => {
                // Ask for confirmation before changing board size (which resets the game)
                const confirmed = await showConfirmationWithOptOut(
                    'Changing the board size will start a new game and lose your current progress. Continue?',
                    confirmationPrefs.boardSizeChange
                );
                if (!confirmed) {
                    // Revert the selection to the current board size
                    const currentBoardSize = game ? game.get_board_size() : 19;
                    event.target.value = currentBoardSize.toString();
                    return;
                }

                // Save the new board size preference
                const newBoardSize = parseInt(event.target.value);
                saveUserPreference(userPrefs.preferredBoardSize, newBoardSize);

                // Clear URL state when user changes board size manually
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);

                // Clear localStorage game state when changing board size
                localStorage.removeItem(userPrefs.lastGameState);

                initGame(); // Start new game with selected size
            });

            // New game button
            document.getElementById('new-game-btn').addEventListener('click', async () => {
                // Ask for confirmation before starting a new game
                const confirmed = await showConfirmationWithOptOut(
                    'Start a new game? This will lose your current progress.',
                    confirmationPrefs.newGame
                );
                if (!confirmed) {
                    return;
                }

                // Clear URL state for fresh game
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);

                // Clear localStorage game state for fresh game
                localStorage.removeItem(userPrefs.lastGameState);

                // Start fresh game
                initGame();
            });

            // Undo button
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (game && game.undo()) {
                    // Play sound effect for undo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Redo button
            document.getElementById('redo-btn').addEventListener('click', () => {
                if (game && game.redo()) {
                    // Play sound effect for redo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Pass button
            document.getElementById('pass-btn').addEventListener('click', () => {
                if (game) {
                    try {
                        const result = game.handle_pass();
                        if (result === "Pass successful") {
                            // Play sound effect for pass
                            soundSystem.playTapSound();

                            drawBoard();
                            updateUndoRedoButtons();
                            updateUrl();

                            // Log pass message
                            const player = game.get_current_player() === 1 ? 'White' : 'Black'; // Previous player (who just passed)
                            const previousPlayer = game.get_current_player() === 1 ? 'Black' : 'White';
                            console.log(`${previousPlayer} passes. ${player}'s turn.`);
                        } else {
                            console.log('Pass not allowed:', result);
                        }
                    } catch (error) {
                        console.error('Pass error:', error);
                    }
                }
            });

            // Copy URL button
            document.getElementById('copy-url-btn').addEventListener('click', async () => {
                if (!game) {
                    console.log('No game to copy URL for');
                    return;
                }

                try {
                    // Ensure URL is up to date with current game state
                    updateUrl();

                    // Copy current URL to clipboard
                    await navigator.clipboard.writeText(window.location.href);

                    // Log success message
                    console.log('Game URL copied to clipboard!');
                } catch (error) {
                    console.error('Failed to copy URL:', error);
                    // Fallback for browsers that don't support clipboard API
                    try {
                        // Create a temporary input element
                        const tempInput = document.createElement('input');
                        tempInput.value = window.location.href;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);

                        console.log('Game URL copied to clipboard!');
                    } catch (fallbackError) {
                        console.error('Fallback copy failed:', fallbackError);
                    }
                }
            });

            // Sound toggle button
            document.getElementById('sound-toggle-btn').addEventListener('click', () => {
                const enabled = soundSystem.toggle();
                const button = document.getElementById('sound-toggle-btn');
                if (enabled) {
                    button.textContent = '🔊 Sound: ON';
                    // Play a test sound to confirm it's working
                    soundSystem.playTapSound();
                } else {
                    button.textContent = '🔇 Sound: OFF';
                }

                // Save sound preference
                saveUserPreference(userPrefs.soundEnabled, enabled);
            });

            // Wake lock toggle button
            document.getElementById('wake-lock-btn').addEventListener('click', async () => {
                const button = document.getElementById('wake-lock-btn');

                if (!wakeLockSystem.isSupported()) {
                    button.textContent = '❌ Keep Screen On: Not Supported';
                    button.disabled = true;
                    button.hidden = true;
                    console.warn('Wake Lock API not supported on this device/browser');
                    return;
                }

                try {
                    const enabled = await wakeLockSystem.toggle();

                    // Update button text
                    updateWakeLockButton();

                    // Save wake lock preference
                    saveUserPreference(userPrefs.wakeLockEnabled, enabled);

                    if (enabled) {
                        console.log('Screen will stay on while game is active');
                    } else {
                        console.log('Screen can dim/sleep normally');
                    }
                } catch (error) {
                    console.error('Error toggling wake lock:', error);
                    button.textContent = '❌ Prevent Sleep: Error';
                }
            });

            // Edit mode toggle button
            document.getElementById('edit-mode-btn').addEventListener('click', async () => {
                const button = document.getElementById('edit-mode-btn');

                if (!editMode && game && game.has_stones_on_board()) {
                    // Warn user about losing undo history
                    const confirmed = await showConfirmationWithOptOut(
                        'Entering edit mode will clear your undo history. Are you sure you want to continue?',
                        confirmationPrefs.editMode
                    );
                    if (!confirmed) {
                        return;
                    }
                }

                editMode = !editMode;
                if (editMode) {
                    button.textContent = '✏️ Edit Mode: ON';
                    button.style.backgroundColor = '#4CAF50';
                    button.style.color = 'white';
                } else {
                    button.textContent = '✏️ Edit Mode: OFF';
                    button.style.backgroundColor = '';
                    button.style.color = '';
                }

                console.log('Edit mode:', editMode ? 'ON' : 'OFF');
            });

            // Handle window resize and orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce resize events
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 100);
            });

            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                // Wait a bit for the orientation to fully change
                setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 250);
            });
        }

        function updateUndoRedoButtons() {
            if (!game) {
                document.getElementById('undo-btn').disabled = true;
                document.getElementById('redo-btn').disabled = true;
                return;
            }

            document.getElementById('undo-btn').disabled = !game.can_undo();
            document.getElementById('redo-btn').disabled = !game.can_redo();
        }

        // Update URL with current game state
        function updateUrl() {
            if (!game || suppressUrlUpdate) return;

            try {
                const state = game.serialize_state();
                const url = new URL(window.location);
                url.searchParams.set('state', state);
                window.history.replaceState(null, '', url);

                // Also save to localStorage for automatic restoration
                saveGameStateToLocalStorage();
            } catch (error) {
                console.warn('Failed to update URL:', error);
            }
        }

        // Load game state from URL
        function loadStateFromUrl() {
            const url = new URL(window.location);
            const stateParam = url.searchParams.get('state');

            if (stateParam && game) {
                suppressUrlUpdate = true;
                try {
                    if (game.deserialize_state(stateParam)) {
                        console.log('Successfully loaded state from URL');
                        // Update board size selector to match loaded state
                        const boardSize = game.get_board_size();
                        document.getElementById('board-size').value = boardSize.toString();
                        return true;
                    } else {
                        console.warn('Failed to deserialize state from URL');
                    }
                } catch (error) {
                    console.warn('Error loading state from URL:', error);
                } finally {
                    suppressUrlUpdate = false;
                }
            }
            return false;
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', () => {
            if (game && loadStateFromUrl()) {
                drawBoard();
                updateUndoRedoButtons();
            }
        });

        function drawBoard() {
            if (!game) return;

            const ctx = canvas.getContext('2d');

            // Get the actual display size (accounting for device pixel ratio scaling)
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Clear canvas
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            // Draw grid lines with crisp lines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Draw horizontal lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const y = Math.round(offsetY + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(Math.round(offsetX) + 0.5, y);
                ctx.lineTo(Math.round(offsetX + boardPixelSize) + 0.5, y);
                ctx.stroke();
            }

            // Draw vertical lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const x = Math.round(offsetX + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(x, Math.round(offsetY) + 0.5);
                ctx.lineTo(x, Math.round(offsetY + boardPixelSize) + 0.5);
                ctx.stroke();
            }

            // Draw star points based on board size
            let starPoints = [];
            if (currentBoardSize === 19) {
                starPoints = [
                    [3, 3], [9, 3], [15, 3],
                    [3, 9], [9, 9], [15, 9],
                    [3, 15], [9, 15], [15, 15]
                ];
            } else if (currentBoardSize === 13) {
                starPoints = [
                    [3, 3], [3, 9], [9, 3], [9, 9], // corners
                    [6, 6] // center
                ];
            } else if (currentBoardSize === 9) {
                starPoints = [
                    [2, 2], [2, 6], [6, 2], [6, 6], // corners
                    [4, 4] // center
                ];
            }

            ctx.fillStyle = '#000';
            const starRadius = Math.max(2, cellSize * 0.08); // Scale star point size with board
            for (let [sx, sy] of starPoints) {
                const x = offsetX + sx * cellSize;
                const y = offsetY + sy * cellSize;
                ctx.beginPath();
                ctx.arc(x, y, starRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw stones with high quality
            for (let y = 0; y < currentBoardSize; y++) {
                for (let x = 0; x < currentBoardSize; x++) {
                    const state = game.get_board_state(x, y);
                    if (state !== 0) {
                        const centerX = offsetX + x * cellSize;
                        const centerY = offsetY + y * cellSize;
                        const radius = cellSize * 0.4;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                        if (state === 1) { // Black
                            ctx.fillStyle = '#000';
                            ctx.fill();
                        } else { // White
                            ctx.fillStyle = '#FFF';
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = Math.max(1, cellSize * 0.05); // Scale stroke width
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw hover preview stone
            if (hoverPosition && isValidBoardPosition(hoverPosition.x, hoverPosition.y)) {
                const centerX = offsetX + hoverPosition.x * cellSize;
                const centerY = offsetY + hoverPosition.y * cellSize;
                const radius = cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                if (editMode) {
                    // Edit mode: show next state in cycle
                    const currentState = game.get_board_state(hoverPosition.x, hoverPosition.y);
                    const nextState = (currentState + 1) % 3; // Cycle: Empty -> Black -> White -> Empty

                    if (nextState === 1) { // Next is Black
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else if (nextState === 2) { // Next is White
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    } else if (nextState === 0 && currentState !== 0) {
                        // Next state is Empty and current state is not empty - show red X to indicate removal
                        const xSize = radius * 0.6; // Size of the X
                        const xOffset = xSize * 0.7; // Distance from center to X endpoints

                        ctx.strokeStyle = '#FF4444'; // Bright red
                        ctx.lineWidth = Math.max(3, cellSize * 0.08); // Thick X
                        ctx.lineCap = 'round'; // Rounded line ends

                        // Draw X (two diagonal lines)
                        ctx.beginPath();
                        ctx.moveTo(centerX - xOffset, centerY - xOffset);
                        ctx.lineTo(centerX + xOffset, centerY + xOffset);
                        ctx.moveTo(centerX + xOffset, centerY - xOffset);
                        ctx.lineTo(centerX - xOffset, centerY + xOffset);
                        ctx.stroke();

                        // Add a subtle red circle background for better visibility
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius * 0.8, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 68, 68, 0.15)'; // Very light red background
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)'; // Light red border
                        ctx.lineWidth = Math.max(1, cellSize * 0.02);
                        ctx.stroke();
                    }
                    // If nextState === 0 and currentState === 0 (empty), don't draw anything for hover
                } else {
                    // Normal game mode: show current player's stone
                    const currentPlayer = game.get_current_player();

                    if (currentPlayer === 1) { // Black preview
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        // Add a subtle border to make it more visible
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else { // White preview
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Subtle border
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    }
                }
            }

            // Highlight the most recent move
            const lastMove = game.get_last_move();
            if (lastMove && lastMove.length === 2) {
                const lastX = lastMove[0];
                const lastY = lastMove[1];
                const centerX = offsetX + lastX * cellSize;
                const centerY = offsetY + lastY * cellSize;
                const highlightRadius = cellSize * 0.3;

                // Draw a colored ring around the last move
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#FF6B6B'; // Red highlight color
                ctx.lineWidth = Math.max(2, cellSize * 0.08); // Thick highlight ring
                ctx.stroke();

                // Add a subtle inner glow effect
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius * 0.7, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)'; // Semi-transparent red
                ctx.lineWidth = Math.max(1, cellSize * 0.04);
                ctx.stroke();
            }

            // Update current player display
            const player = game.get_current_player();
            currentPlayerText.textContent = `Current Player: ${player === 1 ? 'Black' : 'White'}`;

            // Update capture scores
            document.getElementById('black-score').textContent = game.get_black_captures();
            document.getElementById('white-score').textContent = game.get_white_captures();
        }

        // Start the game
        initGame();
    </script>
</body>

</html>
