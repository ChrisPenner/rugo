<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Go</title>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Prevent zoom on double tap in iOS */
            touch-action: manipulation;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            padding: 15px 5px 5px 5px;
            gap: 5px;
            justify-content: center;
        }

        /* Main game area */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }

        /* Responsive canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: min(95vmin, 90vw);
            max-height: min(95vmin, 90vw);
            aspect-ratio: 1;
        }

        #game-canvas {
            border: 2px solid #8B4513;
            background-color: #DEB887;
            cursor: pointer;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
            /* Prevent canvas selection on mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Mobile magnifier for precise placement */
        .magnifier {
            position: fixed;
            width: 180px;
            height: 180px;
            border: 3px solid #333;
            border-radius: 90px;
            background: white;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .magnifier canvas {
            width: 100%;
            height: 100%;
            border-radius: 57px;
        }

        .controls {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin: 10px 0;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 12px;
            color: #666;
        }

        .board-size-controls select {
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-width: 80px;
            min-height: 32px;
        }

        /* Primary button controls container - for most used actions */
        .primary-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
        }

        .primary-controls button {
            padding: 12px 16px;
            font-size: 16px;
            font-weight: 700;
            min-height: 44px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Secondary controls container - for less frequently used actions */
        .secondary-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .secondary-button-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 6px;
            align-items: center;
        }

        /* Single button row for actions like sound toggle */
        .secondary-button-row:has(button:only-child),
        .single-button-row {
            grid-template-columns: 1fr;
            justify-items: center;
        }

        .tertiary-button-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 6px;
            align-items: center;
        }

        /* Single button row for move numbers */
        .tertiary-button-row:has(button:only-child) {
            grid-template-columns: 1fr;
            justify-items: center;
        }


        .secondary-button-row select {
            padding: 8px 10px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-height: 36px;
            text-align: center;
        }

        .secondary-controls button {
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 36px;
            background-color: #6c757d;
            opacity: 0.85;
        }

        .secondary-controls button:hover {
            background-color: #5a6268;
            opacity: 1;
        }

        .secondary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            width: 100%;
        }

        .secondary-grid button {
            padding: 10px 12px;
            font-size: 13px;
            font-weight: 500;
            min-height: 40px;
            background-color: #6c757d;
            opacity: 0.85;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .secondary-grid button:hover {
            background-color: #5a6268;
            opacity: 1;
            transform: translateY(-1px);
        }

        .secondary-grid button:active {
            transform: translateY(0);
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 14px;
            color: #666;
        }

        .board-size-controls select {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: white;
            min-width: 100px;
            min-height: 36px;
        }

        button {
            padding: 15px 20px;
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            /* Improve touch targets */
            min-height: 48px;
            min-width: 120px;
            /* Prevent button text selection */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Add touch feedback */
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            background-color: #3d8b40;
        }

        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            background-color: #cccccc;
            transform: none;
        }

        /* Mobile and tablet optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 20px 3px 3px 3px;
                gap: 5px; /* Direct gap between board and controls */
            }

            .game-area {
                display: flex;
                flex-direction: column;
                align-items: center;
                margin-top: 0; /* Remove top margin to use all available space */
                padding-bottom: 0; /* No bottom padding - controls will be right below */
            }

            .canvas-container {
                max-width: min(92vmin, 95vw);
                max-height: min(92vmin, 95vw);
                margin-bottom: 0; /* No bottom margin - controls will be right below */
            }

            .controls {
                flex-shrink: 0; /* Don't shrink the controls */
            }

            .primary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 40px;
            }

            .secondary-controls {
                padding: 6px;
                gap: 4px;
            }

            .secondary-controls button {
                padding: 6px 8px;
                font-size: 12px;
                min-height: 32px;
            }

            .secondary-grid {
                gap: 6px;
            }

            .secondary-grid button {
                padding: 8px 10px;
                font-size: 12px;
                min-height: 36px;
            }

            .board-size-controls select {
                min-width: 70px;
                min-height: 28px;
                font-size: 11px;
            }
        }

        /* Settings Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 320px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 4px;
            min-height: auto;
            min-width: auto;
            border-radius: 4px;
        }

        .modal-close:hover {
            background-color: #f5f5f5;
            color: #333;
            transform: none;
        }

        .settings-grid {
            display: grid;
            gap: 16px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-label {
            font-size: 14px;
            font-weight: 500;
            color: #555;
        }

        .setting-item button {
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            min-height: 44px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .setting-item button:hover {
            background-color: #5a6268;
            transform: translateY(-1px);
        }

        .setting-item button:active {
            transform: translateY(0);
        }

        .board-size-option {
            padding: 12px 16px !important;
            font-size: 16px !important;
            font-weight: 600 !important;
            min-height: 48px !important;
            background-color: #4CAF50 !important;
            color: white !important;
            border: none !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }

        .board-size-option:hover {
            background-color: #45a049 !important;
            transform: translateY(-1px) !important;
        }

        .board-size-option:active {
            transform: translateY(0) !important;
            background-color: #3d8b40 !important;
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .container {
                padding: 15px 2px 2px 2px;
                gap: 2px;
            }

            .game-area {
                margin-top: 8px;
            }

            .primary-controls {
                gap: 4px;
            }

            .primary-controls button {
                padding: 8px 10px;
                font-size: 13px;
                min-height: 36px;
            }

            .secondary-controls {
                padding: 4px;
                gap: 3px;
            }

            .secondary-button-row {
                grid-template-columns: 1fr;
                gap: 3px;
            }

            .secondary-controls button {
                padding: 5px 6px;
                font-size: 11px;
                min-height: 28px;
            }

            .secondary-grid {
                gap: 4px;
            }

            .secondary-grid button {
                padding: 6px 8px;
                font-size: 11px;
                min-height: 30px;
            }

            .modal-content {
                margin: 20px;
                padding: 20px;
                min-width: 280px;
            }

            .modal-title {
                font-size: 18px;
            }
        }

        /* Wide screen layout (desktop/landscape tablets) - side-by-side layout */
        @media (min-aspect-ratio: 4/3) and (min-width: 768px) {
            .container {
                flex-direction: row;
                padding: 8px;
                gap: 16px;
                align-items: center;
                justify-content: center;
                /* Center the entire content */
            }

            .game-area {
                flex: 0 0 auto;
                /* Don't grow, just size to content */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .canvas-container {
                width: min(85vh, 700px);
                /* Increased from 600px for larger board */
                height: min(85vh, 700px);
                max-width: min(85vh, calc(100vw - 250px));
                max-height: min(85vh, calc(100vw - 250px));
            }

            .controls {
                flex-shrink: 0;
                width: auto;
                min-width: 220px;
                max-height: 85vh;
                gap: 12px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                overflow-y: auto;
                padding: 8px;
            }

            .primary-controls {
                gap: 12px;
            }

            .primary-controls button {
                padding: 14px 18px;
                font-size: 16px;
                min-height: 48px;
                min-width: auto;
                width: 100%;
                white-space: nowrap;
            }

            .secondary-controls {
                padding: 12px;
                gap: 8px;
            }

            .secondary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 38px;
                min-width: auto;
                white-space: nowrap;
            }

            .secondary-grid {
                gap: 10px;
            }

            .secondary-grid button {
                padding: 12px 14px;
                font-size: 14px;
                min-height: 42px;
                min-width: auto;
                white-space: nowrap;
            }

            .secondary-button-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                gap: 8px;
                align-items: center;
            }

            .secondary-button-row select {
                padding: 10px 12px;
                font-size: 14px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background-color: white;
                min-height: 38px;
            }

            .secondary-button-row button {
                flex: 1;
            }
        }

        /* Extra large screens - optimize layout for desktop monitors */
        @media (min-width: 1200px) {
            .container {
                max-width: 1100px;
                /* Increased to accommodate larger board */
                margin: 0 auto;
                /* Center the entire game container */
                justify-content: space-between;
                /* Space between board and controls */
            }

            .canvas-container {
                width: 750px;
                /* Increased from 600px for better gameplay experience */
                height: 750px;
            }

            .controls {
                min-width: 240px;
                /* Slightly wider controls for better readability */
            }
        }

        /* Mobile landscape (smaller screens) - compact horizontal layout */
        @media (max-height: 600px) and (orientation: landscape) and (max-width: 767px) {
            .container {
                flex-direction: row;
                padding: 3px;
                gap: 8px;
            }

            .game-area {
                flex: 1;
            }

            .controls {
                flex-shrink: 0;
                width: 200px;
                max-height: none;
                margin-top: 8px;
            }




        }
    </style>
</head>

<body>
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="game-canvas" width="600" height="600"></canvas>
                <div class="magnifier" id="magnifier">
                    <canvas id="magnifier-canvas" width="180" height="180"></canvas>
                </div>
            </div>
        </div>

        <div class="controls">
            <!-- Primary game controls - most frequently used -->
            <div class="primary-controls">
                <button id="undo-btn" disabled>Undo</button>
                <button id="redo-btn" disabled>Redo</button>
                <button id="pass-btn">Pass</button>
            </div>

            <!-- Secondary controls - less frequently used -->
            <div class="secondary-controls">
                <div class="secondary-grid">
                    <button id="new-game-btn">New Game</button>
                    <button id="settings-btn">‚öôÔ∏è Settings</button>
                    <!-- <button id="edit-mode-btn">‚úèÔ∏è Edit Mode</button> -->
                    <button id="screenshot-btn">üì∏ Screenshot</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Settings</h2>
                <button class="modal-close" id="settings-close">&times;</button>
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">Audio</div>
                    <button id="sound-toggle-btn">üîä Sound: ON</button>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Display</div>
                    <button id="wake-lock-btn">ÔøΩ Prevent Sleep: OFF</button>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Stones</div>
                    <button id="move-numbers-btn">üî¢ Move Numbers: OFF</button>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Share</div>
                    <button id="copy-url-btn">üìã Copy Game State</button>
                </div>
            </div>
        </div>
    </div>

    <!-- New Game Modal -->
    <div id="new-game-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Start New Game</h2>
                <button class="modal-close" id="new-game-close">&times;</button>
            </div>
            <div class="settings-grid">
                <div class="setting-item">
                    <div class="setting-label">‚ö†Ô∏è Warning</div>
                    <p style="color: #d73527; font-size: 14px; margin: 0; line-height: 1.4;">
                        Starting a new game will lose your current progress and cannot be undone.
                    </p>
                </div>
                <div class="setting-item">
                    <div class="setting-label">Choose Board Size</div>
                    <div style="display: grid; gap: 8px;">
                        <button id="new-game-9x9" class="board-size-option">9√ó9 Board</button>
                        <button id="new-game-13x13" class="board-size-option">13√ó13 Board</button>
                        <button id="new-game-19x19" class="board-size-option">19√ó19 Board</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { GoGame } from './pkg/rugo.js';

        let game = null;
        const canvas = document.getElementById('game-canvas');
        let suppressUrlUpdate = false; // Flag to prevent infinite loops
        let eventListenersSetup = false; // Flag to prevent duplicate event listeners
        let hoverPosition = null; // Track mouse position for hover preview
        let editMode = false; // Track whether we're in edit mode
        let isDragging = false; // Track if we're currently dragging in edit mode
        let dragState = null; // The state to apply while dragging (0, 1, or 2)
        let showMoveNumbers = false; // Track whether to display move numbers on stones

        // Sound system for game audio feedback
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.volume = 0.3; // Keep sounds subtle
                this.initAudioContext();
            }

            async initAudioContext() {
                try {
                    // Create audio context on first user interaction
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Resume context if it's suspended (required for some browsers)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                } catch (error) {
                    console.warn('Audio not supported:', error);
                    this.enabled = false;
                }
            }

            async ensureAudioContext() {
                if (!this.audioContext) {
                    await this.initAudioContext();
                }
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            // Create a bright, sharp tap sound like stone on wood with subtle randomness
            async playTapSound() {
                if (!this.enabled || !this.audioContext) return;

                try {
                    await this.ensureAudioContext();

                    // Add subtle randomness for natural variation
                    const randomVariation = () => 0.85 + Math.random() * 0.3; // ¬±15% variation
                    const pitchVariation = () => 0.9 + Math.random() * 0.2; // ¬±10% pitch variation
                    const timingVariation = () => 0.8 + Math.random() * 0.4; // ¬±20% timing variation

                    // Create multiple oscillators for a rich, full-spectrum sound
                    const oscillator1 = this.audioContext.createOscillator(); // Primary mid-range
                    const oscillator2 = this.audioContext.createOscillator(); // High harmonic
                    const oscillator3 = this.audioContext.createOscillator(); // Low body
                    const gainNode1 = this.audioContext.createGain();
                    const gainNode2 = this.audioContext.createGain();
                    const gainNode3 = this.audioContext.createGain();
                    const masterGain = this.audioContext.createGain();

                    // Connect nodes
                    oscillator1.connect(gainNode1);
                    oscillator2.connect(gainNode2);
                    oscillator3.connect(gainNode3);
                    gainNode1.connect(masterGain);
                    gainNode2.connect(masterGain);
                    gainNode3.connect(masterGain);
                    masterGain.connect(this.audioContext.destination);

                    // Primary tap sound with slight pitch variation
                    const baseFreq1 = 1200 * pitchVariation();
                    const endFreq1 = 400 * pitchVariation();
                    oscillator1.frequency.setValueAtTime(baseFreq1, this.audioContext.currentTime);
                    oscillator1.frequency.exponentialRampToValueAtTime(endFreq1, this.audioContext.currentTime + 0.008 * timingVariation());

                    // Secondary harmonic with variation
                    const baseFreq2 = 2400 * pitchVariation();
                    const endFreq2 = 800 * pitchVariation();
                    oscillator2.frequency.setValueAtTime(baseFreq2, this.audioContext.currentTime);
                    oscillator2.frequency.exponentialRampToValueAtTime(endFreq2, this.audioContext.currentTime + 0.005 * timingVariation());

                    // Low frequency component with variation
                    const baseFreq3 = 200 * pitchVariation();
                    const endFreq3 = 80 * pitchVariation();
                    oscillator3.frequency.setValueAtTime(baseFreq3, this.audioContext.currentTime);
                    oscillator3.frequency.exponentialRampToValueAtTime(endFreq3, this.audioContext.currentTime + 0.012 * timingVariation());

                    // Sharp attack envelope for primary sound with volume variation
                    gainNode1.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode1.gain.linearRampToValueAtTime(this.volume * 0.8 * randomVariation(), this.audioContext.currentTime + 0.0005 * timingVariation());
                    gainNode1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.04 * timingVariation());

                    // Brighter harmonic with variation
                    gainNode2.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode2.gain.linearRampToValueAtTime(this.volume * 0.4 * randomVariation(), this.audioContext.currentTime + 0.0003 * timingVariation());
                    gainNode2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.02 * timingVariation());

                    // Low frequency body with variation
                    gainNode3.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode3.gain.linearRampToValueAtTime(this.volume * 0.3 * randomVariation(), this.audioContext.currentTime + 0.001 * timingVariation());
                    gainNode3.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.035 * timingVariation());

                    // Master volume control with slight variation
                    masterGain.gain.setValueAtTime(this.volume * randomVariation(), this.audioContext.currentTime);

                    // Play the sound with randomized durations
                    const duration1 = 0.04 * timingVariation();
                    const duration2 = 0.02 * timingVariation();
                    const duration3 = 0.035 * timingVariation();

                    oscillator1.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + duration1);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator2.stop(this.audioContext.currentTime + duration2);
                    oscillator3.start(this.audioContext.currentTime);
                    oscillator3.stop(this.audioContext.currentTime + duration3);

                } catch (error) {
                    console.warn('Error playing sound:', error);
                }
            }

            // Toggle sound on/off
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }

            // Set volume (0.0 to 1.0)
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }
        }

        // Wake lock system to prevent screen from dimming/sleeping
        class WakeLockSystem {
            constructor() {
                this.wakeLock = null;
                this.enabled = false;
                this.supported = 'wakeLock' in navigator;

                // Handle visibility change to re-acquire wake lock
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.enabled) {
                        this.requestWakeLock();
                    }
                });
            }

            async requestWakeLock() {
                if (!this.supported) {
                    console.warn('Wake Lock API not supported');
                    return false;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired - screen will stay on');

                    // Listen for wake lock release
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake lock released');
                    });

                    return true;
                } catch (error) {
                    console.warn('Failed to acquire wake lock:', error);
                    return false;
                }
            }

            async releaseWakeLock() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('Wake lock manually released');
                    } catch (error) {
                        console.warn('Error releasing wake lock:', error);
                    }
                }
            }

            async toggle() {
                if (this.enabled) {
                    // Turn off wake lock
                    this.enabled = false;
                    await this.releaseWakeLock();
                    return false;
                } else {
                    // Turn on wake lock
                    this.enabled = true;
                    const success = await this.requestWakeLock();
                    if (!success) {
                        this.enabled = false;
                    }
                    return this.enabled;
                }
            }

            isSupported() {
                return this.supported;
            }

            isEnabled() {
                return this.enabled;
            }
        }

        // Initialize sound system
        const soundSystem = new SoundSystem();

        // Initialize wake lock system
        const wakeLockSystem = new WakeLockSystem();

        // Confirmation preferences stored in localStorage
        const confirmationPrefs = {
            boardSizeChange: 'confirm_board_size_change',
            newGame: 'confirm_new_game',
            editMode: 'confirm_edit_mode'
        };

        // User preference storage keys
        const userPrefs = {
            soundEnabled: 'sound_enabled',
            wakeLockEnabled: 'wake_lock_enabled',
            preferredBoardSize: 'preferred_board_size',
            lastGameState: 'last_game_state',
            moveNumbersEnabled: 'move_numbers_enabled'
        };

        // Function to save user preferences to localStorage
        function saveUserPreference(key, value) {
            try {
                localStorage.setItem(key, value.toString());
            } catch (error) {
                console.warn('Failed to save preference:', error);
            }
        }

        // Function to load user preferences from localStorage
        function loadUserPreference(key, defaultValue) {
            try {
                const stored = localStorage.getItem(key);
                if (stored === null) return defaultValue;

                // Handle boolean values
                if (defaultValue === true || defaultValue === false) {
                    return stored === 'true';
                }

                // Handle numeric values
                if (typeof defaultValue === 'number') {
                    const parsed = parseInt(stored, 10);
                    return isNaN(parsed) ? defaultValue : parsed;
                }

                // Handle string values
                return stored;
            } catch (error) {
                console.warn('Failed to load preference:', error);
                return defaultValue;
            }
        }

        // Function to save current game state to localStorage
        function saveGameStateToLocalStorage() {
            if (!game) return;

            try {
                const state = game.serialize_state();
                localStorage.setItem(userPrefs.lastGameState, state);
                console.log('Game state saved to localStorage');
            } catch (error) {
                console.warn('Failed to save game state to localStorage:', error);
            }
        }

        // Function to load game state from localStorage
        function loadGameStateFromLocalStorage() {
            try {
                const state = localStorage.getItem(userPrefs.lastGameState);
                if (state && game) {
                    if (game.deserialize_state(state)) {
                        console.log('Game state restored from localStorage');
                        return true;
                    } else {
                        console.warn('Failed to deserialize game state from localStorage');
                    }
                }
            } catch (error) {
                console.warn('Failed to load game state from localStorage:', error);
            }
            return false;
        }

        // Utility function to show confirmation with "Don't notify me again" option
        function showConfirmationWithOptOut(message, prefKey) {
            // Check if user has opted out of this confirmation
            const skipConfirm = localStorage.getItem(prefKey) === 'false';
            if (skipConfirm) {
                return true; // Always proceed if user opted out
            }

            // Create a custom dialog with checkbox
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: Arial, sans-serif;
            `;

            const dialogBox = document.createElement('div');
            dialogBox.style.cssText = `
                background: white;
                padding: 24px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                min-width: 320px;
                text-align: center;
            `;

            const messageText = document.createElement('p');
            messageText.textContent = message;
            messageText.style.cssText = `
                margin: 0 0 20px 0;
                font-size: 16px;
                line-height: 1.4;
                color: #333;
            `;

            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = `
                margin: 16px 0 20px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            `;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = 'dont-notify-again';
            checkbox.style.cssText = `
                margin: 0;
                transform: scale(1.2);
            `;

            const checkboxLabel = document.createElement('label');
            checkboxLabel.htmlFor = 'dont-notify-again';
            checkboxLabel.textContent = "Don't ask me again";
            checkboxLabel.style.cssText = `
                font-size: 14px;
                color: #666;
                cursor: pointer;
                user-select: none;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 12px;
                justify-content: center;
            `;

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background: #f8f9fa;
                color: #333;
                font-size: 14px;
                cursor: pointer;
                min-width: 80px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Continue';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: none;
                border-radius: 4px;
                background: #4CAF50;
                color: white;
                font-size: 14px;
                cursor: pointer;
                min-width: 80px;
            `;

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(checkboxLabel);
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);
            dialogBox.appendChild(messageText);
            dialogBox.appendChild(checkboxContainer);
            dialogBox.appendChild(buttonContainer);
            dialog.appendChild(dialogBox);
            document.body.appendChild(dialog);

            return new Promise((resolve) => {
                const cleanup = () => {
                    document.body.removeChild(dialog);
                };

                cancelButton.addEventListener('click', () => {
                    if (checkbox.checked) {
                        localStorage.setItem(prefKey, 'false');
                    }
                    cleanup();
                    resolve(false);
                });

                confirmButton.addEventListener('click', () => {
                    if (checkbox.checked) {
                        localStorage.setItem(prefKey, 'false');
                    }
                    cleanup();
                    resolve(true);
                });

                // Close on escape key
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        document.removeEventListener('keydown', handleKeydown);
                        cleanup();
                        resolve(false);
                    }
                };
                document.addEventListener('keydown', handleKeydown);
            });
        }

        // Helper function to get board coordinates from mouse/touch event
        function getBoardPositionFromEvent(event) {
            if (!game) return null;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Handle both touch and mouse events
            if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    return null;
                }
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Calculate coordinates relative to the displayed canvas size
            // Account for device pixel ratio scaling
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            const canvasX = (clientX - rect.left) * (displayWidth / rect.width);
            const canvasY = (clientY - rect.top) * (displayHeight / rect.height);

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Calculate board layout (same as in drawBoard)
            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Convert canvas coordinates to board coordinates
            const boardX = Math.round((canvasX - offsetX) / cellSize);
            const boardY = Math.round((canvasY - offsetY) / cellSize);

            return { x: boardX, y: boardY };
        }

        // Helper function to check if board position is valid for placing a stone
        function isValidBoardPosition(boardX, boardY) {
            if (!game) return false;

            const currentBoardSize = game.get_board_size();

            // Check if position is within board bounds
            if (boardX < 0 || boardX >= currentBoardSize || boardY < 0 || boardY >= currentBoardSize) {
                return false;
            }

            // In edit mode, allow clicking on any position (empty or occupied)
            if (editMode) {
                return true;
            }

            // In normal game mode, check if position is empty
            return game.get_board_state(boardX, boardY) === 0;
        }

        async function initGame() {
            try {
                // Initialize the wasm module
                await init();

                // Restore user preferences
                restoreUserPreferences();

                // Get preferred board size from user preferences
                const boardSize = loadUserPreference(userPrefs.preferredBoardSize, 19);

                // Set up responsive canvas sizing
                setupResponsiveCanvas();

                // Create game instance with selected size
                game = GoGame.new_with_size(canvas, boardSize);

                // Set up event listeners (only once)
                if (!eventListenersSetup) {
                    setupEventListeners();
                }

                // Try to load state from URL first, then localStorage, otherwise draw fresh board
                if (!loadStateFromUrl()) {
                    if (!loadGameStateFromLocalStorage()) {
                        updateUrl(); // Set initial state in URL only for fresh games
                    } else {
                        // If we loaded from localStorage, update URL to match
                        updateUrl();
                    }
                }
                drawBoard();
                updateUndoRedoButtons();

            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        }

        // Function to restore all user preferences
        function restoreUserPreferences() {
            // Restore sound preference
            const soundEnabled = loadUserPreference(userPrefs.soundEnabled, true);
            soundSystem.enabled = soundEnabled;
            const soundButton = document.getElementById('sound-toggle-btn');
            soundButton.textContent = soundEnabled ? 'üîä Sound: ON' : 'üîá Sound: OFF';

            // Restore wake lock preference
            const wakeLockEnabled = loadUserPreference(userPrefs.wakeLockEnabled, false);
            if (wakeLockEnabled && wakeLockSystem.isSupported()) {
                // Try to enable wake lock on startup
                wakeLockSystem.toggle().then(() => {
                    updateWakeLockButton();
                }).catch(() => {
                    // If it fails, update button to show OFF state
                    updateWakeLockButton();
                });
            } else {
                updateWakeLockButton();
            }

            // Restore move numbers preference
            const moveNumbersEnabled = loadUserPreference(userPrefs.moveNumbersEnabled, false);
            showMoveNumbers = moveNumbersEnabled;
            const moveNumbersButton = document.getElementById('move-numbers-btn');
            moveNumbersButton.textContent = showMoveNumbers ? 'üî¢ Move Numbers: ON' : 'üî¢ Move Numbers: OFF';
        }

        // Function to update wake lock button text
        function updateWakeLockButton() {
            const button = document.getElementById('wake-lock-btn');
            if (!wakeLockSystem.isSupported()) {
                button.textContent = '‚ùå Keep Screen On: Not Supported';
                button.disabled = true;
                button.hidden = true;
            } else if (wakeLockSystem.isEnabled()) {
                button.textContent = 'üí° Prevent Sleep: ON';
            } else {
                button.textContent = 'üí° Prevent Sleep: OFF';
            }
        }

        function setupResponsiveCanvas() {
            const container = document.querySelector('.canvas-container');
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);

            // Get device pixel ratio for high-DPI displays
            const devicePixelRatio = window.devicePixelRatio || 1;

            // Calculate the actual pixel size we want to render at
            const displaySize = Math.floor(size);
            const renderSize = Math.floor(displaySize * devicePixelRatio);

            // Set canvas internal dimensions to high resolution
            canvas.width = renderSize;
            canvas.height = renderSize;

            // Set CSS size to display size
            canvas.style.width = displaySize + 'px';
            canvas.style.height = displaySize + 'px';

            // Scale the context to match device pixel ratio
            const ctx = canvas.getContext('2d');
            ctx.scale(devicePixelRatio, devicePixelRatio);

            console.log(`Canvas setup: Display ${displaySize}px, Render ${renderSize}px, DPR ${devicePixelRatio}`);
        }

        function setupEventListeners() {
            if (eventListenersSetup) return; // Prevent duplicate listeners
            eventListenersSetup = true;

            // Helper function to handle board interactions
            function handleBoardInteraction(event) {
                if (!game) return;

                // Prevent default touch behaviors
                event.preventDefault();

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if click is within board bounds and position is valid
                if (isValidBoardPosition(boardX, boardY)) {
                    try {
                        if (editMode) {
                            // Edit mode: cycle through states (Empty -> Black -> White -> Empty)
                            const currentState = game.get_board_state(boardX, boardY);

                            // Cycle: 0 (Empty) -> 1 (Black) -> 2 (White) -> 0 (Empty)
                            const nextState = (currentState + 1) % 3;

                            console.log(`Edit mode: position (${boardX}, ${boardY}), current state: ${currentState}, next state: ${nextState}`);

                            const result = game.set_board_position(boardX, boardY, nextState);
                            console.log(`Set position result: ${result}`);

                            if (result === "Position set successfully") {
                                // Start dragging with this state
                                isDragging = true;
                                dragState = nextState;

                                // Play sound effect for edit action
                                soundSystem.playTapSound();

                                // Keep hover position to continue showing preview for multiple clicks
                                // hoverPosition remains unchanged so the preview continues to show

                                drawBoard();
                                // Don't update URL here - wait until drag ends
                            } else {
                                console.log('Edit not allowed:', result);
                            }
                        } else {
                            // Normal game mode
                            const result = game.handle_board_click(boardX, boardY);
                            if (result === "Move successful") {
                                // Play sound effect for successful stone placement
                                soundSystem.playTapSound();

                                // Clear hover position after successful move
                                hoverPosition = null;

                                drawBoard();
                                updateUndoRedoButtons();
                                updateUrl();
                            } else {
                                // Log error message
                                console.log('Move not allowed:', result);
                            }
                        }
                    } catch (error) {
                        console.error('Board interaction error:', error);
                    }
                }
            }

            // Helper function to handle dragging in edit mode
            function handleEditDrag(event) {
                if (!game || !editMode || !isDragging || dragState === null) return;

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if position is within board bounds
                if (isValidBoardPosition(boardX, boardY)) {
                    // Only apply the drag state if the current position doesn't already have it
                    const currentState = game.get_board_state(boardX, boardY);
                    if (currentState !== dragState) {
                        const result = game.set_board_position(boardX, boardY, dragState);
                        if (result === "Position set successfully") {
                            drawBoard();
                        }
                    }
                }
            }

            // Canvas mousedown handler for drag start
            canvas.addEventListener('mousedown', (event) => {
                if (editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Canvas mouseup handler for drag end
            canvas.addEventListener('mouseup', (event) => {
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL once at the end of drag

                    // Restore hover position for continued preview
                    const boardPos = getBoardPositionFromEvent(event);
                    if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                        hoverPosition = boardPos;
                        drawBoard(); // Redraw to show the hover preview
                    }
                }
            });

            // Canvas click handler for non-edit mode
            canvas.addEventListener('click', (event) => {
                if (!editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Mouse move handler for hover preview and dragging
            canvas.addEventListener('mousemove', (event) => {
                if (!game) return;

                // Handle dragging in edit mode
                if (editMode && isDragging) {
                    handleEditDrag(event);
                }

                // Handle hover preview
                const boardPos = getBoardPositionFromEvent(event);
                if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                    hoverPosition = boardPos;
                } else {
                    hoverPosition = null;
                }

                // Only redraw for hover if we're not dragging (to avoid excessive redraws)
                if (!isDragging) {
                    drawBoard(); // Redraw to show/hide hover preview
                }
            });

            // Mouse leave handler to clear hover preview and stop dragging
            canvas.addEventListener('mouseleave', () => {
                hoverPosition = null;
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL when drag ends
                }
                drawBoard();
            });

            // Magnifier functionality for mobile touch precision
            const magnifier = document.getElementById('magnifier');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const magnifierCtx = magnifierCanvas.getContext('2d');
            let magnifierScale = 2.0; // Magnification level

            function showMagnifier(touch) {
                // Position the magnifier above the finger
                const magnifierWidth = 180;
                const magnifierHeight = 180;
                const offsetY = magnifierHeight + 30; // Space above finger

                // Get touch position relative to viewport (clientX/Y for absolute positioning)
                let x = touch.clientX - magnifierWidth / 2;
                let y = touch.clientY - offsetY;

                // Keep magnifier within viewport horizontally, but allow vertical clipping
                const viewportWidth = window.innerWidth;

                // Only constrain horizontally - allow vertical overflow for better UX
                if (x < 10) x = 10;
                if (x + magnifierWidth > viewportWidth - 10) x = viewportWidth - magnifierWidth - 10;

                // Don't constrain vertically - let it clip off screen to maintain relative position

                magnifier.style.left = x + 'px';
                magnifier.style.top = y + 'px';
                magnifier.style.display = 'block';

                // Draw magnified content immediately
                drawMagnifierContent(touch);
            } function hideMagnifier() {
                magnifier.style.display = 'none';
            }

            function drawMagnifierContent(touch) {
                const rect = canvas.getBoundingClientRect();

                // Get touch position relative to canvas display size
                const canvasDisplayX = touch.clientX - rect.left;
                const canvasDisplayY = touch.clientY - rect.top;

                // Account for device pixel ratio - canvas internal size vs display size
                const devicePixelRatio = window.devicePixelRatio || 1;
                const canvasX = canvasDisplayX * devicePixelRatio;
                const canvasY = canvasDisplayY * devicePixelRatio;

                // Clear magnifier canvas
                magnifierCtx.clearRect(0, 0, 180, 180);

                // Calculate source area - use display-sized area to get actual size in magnifier
                const displaySourceSize = 180; // 180px in display coordinates
                const canvasSourceSize = displaySourceSize * devicePixelRatio; // Scale up for canvas coordinates
                const sourceX = canvasX - canvasSourceSize / 2;
                const sourceY = canvasY - canvasSourceSize / 2;

                // Save context for clipping
                magnifierCtx.save();

                // Create circular clipping mask
                magnifierCtx.beginPath();
                magnifierCtx.arc(90, 90, 87, 0, 2 * Math.PI);
                magnifierCtx.clip();

                // Draw actual-size portion of main canvas
                magnifierCtx.drawImage(
                    canvas,
                    sourceX, sourceY, canvasSourceSize, canvasSourceSize,  // Source area (canvas coordinates)
                    0, 0, 180, 180                                          // Destination area (display size = actual size)
                );

                // Draw hover preview stone if we're over a valid position
                const boardPos = getBoardPositionFromEvent(touch);
                if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                    // Calculate board layout parameters (same as in drawBoard)
                    const displayWidth = canvas.width / devicePixelRatio;
                    const displayHeight = canvas.height / devicePixelRatio;
                    const currentBoardSize = game.get_board_size();
                    const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
                    const boardPixelSize = cellSize * (currentBoardSize - 1);
                    const offsetX = (displayWidth - boardPixelSize) / 2;
                    const offsetY = (displayHeight - boardPixelSize) / 2;

                    // Calculate stone position in display coordinates
                    const stoneDisplayX = offsetX + boardPos.x * cellSize;
                    const stoneDisplayY = offsetY + boardPos.y * cellSize;

                    // Convert to magnifier coordinates
                    const stoneMagnifierX = stoneDisplayX - canvasDisplayX + 90; // Center at crosshair
                    const stoneMagnifierY = stoneDisplayY - canvasDisplayY + 90;

                    // Only draw if the stone position is within the magnifier view
                    if (stoneMagnifierX >= 0 && stoneMagnifierX <= 180 && stoneMagnifierY >= 0 && stoneMagnifierY <= 180) {
                        const currentPlayer = game.get_current_player();
                        const stoneRadius = Math.max(4, cellSize * 0.45);

                        // Draw stone with transparency to indicate it's a preview
                        magnifierCtx.globalAlpha = 0.7;
                        magnifierCtx.beginPath();
                        magnifierCtx.arc(stoneMagnifierX, stoneMagnifierY, stoneRadius, 0, 2 * Math.PI);

                        if (currentPlayer === 1) { // Black
                            magnifierCtx.fillStyle = '#000';
                            magnifierCtx.fill();
                            magnifierCtx.strokeStyle = '#333';
                        } else { // White
                            magnifierCtx.fillStyle = '#fff';
                            magnifierCtx.fill();
                            magnifierCtx.strokeStyle = '#ccc';
                        }
                        magnifierCtx.lineWidth = 1;
                        magnifierCtx.stroke();
                        magnifierCtx.globalAlpha = 1.0; // Reset alpha
                    }
                }

                // Draw crosshair for precise targeting
                magnifierCtx.restore(); // Restore to draw crosshair outside clipping
                magnifierCtx.strokeStyle = '#ff0000';
                magnifierCtx.lineWidth = 2;
                magnifierCtx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                magnifierCtx.shadowBlur = 2;
                magnifierCtx.beginPath();
                magnifierCtx.moveTo(90, 75);
                magnifierCtx.lineTo(90, 105);
                magnifierCtx.moveTo(75, 90);
                magnifierCtx.lineTo(105, 90);
                magnifierCtx.stroke();
                magnifierCtx.shadowBlur = 0; // Reset shadow
            }

            // Touch event handlers for better mobile support with drag functionality
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // In edit mode, start dragging immediately
                    handleBoardInteraction(event);
                } else {
                    // Store the touch for potential stone placement in normal mode
                    canvas._touchStartTime = Date.now();
                    canvas._touchStartPos = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };

                    // Set a timeout to show magnifier after 500ms
                    canvas._magnifierTimeout = setTimeout(() => {
                        // Only show if the touch is still active
                        if (canvas._touchStartTime) {
                            showMagnifier(event.touches[0]);
                        }
                    }, 500);
                }
            });

            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode && isDragging) {
                    // Handle dragging in edit mode
                    handleEditDrag(event);
                } else if (!editMode && canvas._touchStartTime) {
                    // Only update magnifier position if it's already visible
                    const magnifier = document.getElementById('magnifier');
                    if (magnifier.style.display === 'block') {
                        // Use requestAnimationFrame for smooth updates
                        requestAnimationFrame(() => {
                            showMagnifier(event.touches[0]);
                        });
                    }
                }
            });

            canvas.addEventListener('touchend', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // End dragging in edit mode
                    if (isDragging) {
                        isDragging = false;
                        dragState = null;
                        updateUrl(); // Update URL when drag ends

                        // For touch, we don't maintain hover position since there's no persistent cursor
                        // Touch interactions are discrete events
                    }

                    // Clear magnifier timeout if it exists (in case edit mode was toggled during touch)
                    if (canvas._magnifierTimeout) {
                        clearTimeout(canvas._magnifierTimeout);
                        delete canvas._magnifierTimeout;
                    }
                } else {
                    // Handle stone placement in normal mode
                    if (canvas._touchStartTime && canvas._touchStartPos) {
                        const touch = event.changedTouches[0];

                        // Always try to place a stone at the final touch position
                        // This creates the "drag to place" behavior
                        const finalBoardPos = getBoardPositionFromEvent(event);
                        if (finalBoardPos && isValidBoardPosition(finalBoardPos.x, finalBoardPos.y)) {
                            try {
                                const result = game.handle_board_click(finalBoardPos.x, finalBoardPos.y);
                                if (result === "Move successful") {
                                    // Play sound effect for successful stone placement
                                    soundSystem.playTapSound();

                                    drawBoard();
                                    updateUndoRedoButtons();
                                    updateUrl();
                                }
                            } catch (error) {
                                console.error('Stone placement error:', error);
                            }
                        }
                    }

                    // Clean up
                    delete canvas._touchStartTime;
                    delete canvas._touchStartPos;

                    // Clear magnifier timeout if it hasn't fired yet
                    if (canvas._magnifierTimeout) {
                        clearTimeout(canvas._magnifierTimeout);
                        delete canvas._magnifierTimeout;
                    }

                    hideMagnifier(); // Hide magnifier when touch ends
                }
            });

            // Prevent context menu on touch devices
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            // New game button - open modal for board size selection
            document.getElementById('new-game-btn').addEventListener('click', () => {
                const newGameModal = document.getElementById('new-game-modal');
                newGameModal.classList.add('show');
            });

            // New game modal functionality
            const newGameModal = document.getElementById('new-game-modal');
            const newGameClose = document.getElementById('new-game-close');

            // Close new game modal
            const closeNewGame = () => {
                newGameModal.classList.remove('show');
            };

            newGameClose.addEventListener('click', closeNewGame);

            // Close modal when clicking outside
            newGameModal.addEventListener('click', (e) => {
                if (e.target === newGameModal) {
                    closeNewGame();
                }
            });

            // Board size selection handlers
            const startNewGame = (boardSize) => {
                // Clear URL state for fresh game
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);

                // Clear localStorage game state for fresh game
                localStorage.removeItem(userPrefs.lastGameState);

                // Save the new board size preference
                saveUserPreference(userPrefs.preferredBoardSize, boardSize);

                // Close modal
                closeNewGame();

                // Create a new game with the selected size
                game = GoGame.new_with_size(canvas, boardSize);
                setupResponsiveCanvas();
                drawBoard();
                updateUndoRedoButtons();
                updateUrl();
            }; document.getElementById('new-game-9x9').addEventListener('click', () => startNewGame(9));
            document.getElementById('new-game-13x13').addEventListener('click', () => startNewGame(13));
            document.getElementById('new-game-19x19').addEventListener('click', () => startNewGame(19));

            // Undo button
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (game && game.undo()) {
                    // Play sound effect for undo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Redo button
            document.getElementById('redo-btn').addEventListener('click', () => {
                if (game && game.redo()) {
                    // Play sound effect for redo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Pass button
            document.getElementById('pass-btn').addEventListener('click', () => {
                if (game) {
                    try {
                        const result = game.handle_pass();
                        if (result === "Pass successful") {
                            // Play sound effect for pass
                            soundSystem.playTapSound();

                            drawBoard();
                            updateUndoRedoButtons();
                            updateUrl();

                            // Log pass message
                            const player = game.get_current_player() === 1 ? 'White' : 'Black'; // Previous player (who just passed)
                            const previousPlayer = game.get_current_player() === 1 ? 'Black' : 'White';
                            console.log(`${previousPlayer} passes. ${player}'s turn.`);
                        } else {
                            console.log('Pass not allowed:', result);
                        }
                    } catch (error) {
                        console.error('Pass error:', error);
                    }
                }
            });

            // Copy URL button
            document.getElementById('copy-url-btn').addEventListener('click', async () => {
                if (!game) {
                    console.log('No game to copy URL for');
                    return;
                }

                try {
                    // Ensure URL is up to date with current game state
                    updateUrl();

                    // Copy current URL to clipboard
                    await navigator.clipboard.writeText(window.location.href);

                    // Log success message
                    console.log('Game URL copied to clipboard!');
                } catch (error) {
                    console.error('Failed to copy URL:', error);
                    // Fallback for browsers that don't support clipboard API
                    try {
                        // Create a temporary input element
                        const tempInput = document.createElement('input');
                        tempInput.value = window.location.href;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);

                        console.log('Game URL copied to clipboard!');
                    } catch (fallbackError) {
                        console.error('Fallback copy failed:', fallbackError);
                    }
                }
            });

            // Sound toggle button
            document.getElementById('sound-toggle-btn').addEventListener('click', () => {
                const enabled = soundSystem.toggle();
                const button = document.getElementById('sound-toggle-btn');
                if (enabled) {
                    button.textContent = 'üîä Sound: ON';
                    // Play a test sound to confirm it's working
                    soundSystem.playTapSound();
                } else {
                    button.textContent = 'üîá Sound: OFF';
                }

                // Save sound preference
                saveUserPreference(userPrefs.soundEnabled, enabled);
            });

            // Wake lock toggle button
            document.getElementById('wake-lock-btn').addEventListener('click', async () => {
                const button = document.getElementById('wake-lock-btn');

                if (!wakeLockSystem.isSupported()) {
                    button.textContent = '‚ùå Keep Screen On: Not Supported';
                    button.disabled = true;
                    button.hidden = true;
                    console.warn('Wake Lock API not supported on this device/browser');
                    return;
                }

                try {
                    const enabled = await wakeLockSystem.toggle();

                    // Update button text
                    updateWakeLockButton();

                    // Save wake lock preference
                    saveUserPreference(userPrefs.wakeLockEnabled, enabled);

                    if (enabled) {
                        console.log('Screen will stay on while game is active');
                    } else {
                        console.log('Screen can dim/sleep normally');
                    }
                } catch (error) {
                    console.error('Error toggling wake lock:', error);
                    button.textContent = '‚ùå Prevent Sleep: Error';
                }
            });

            /*
            // Edit mode toggle button (disabled for now)
            document.getElementById('edit-mode-btn').addEventListener('click', async () => {
                const button = document.getElementById('edit-mode-btn');

                if (!editMode && game && game.has_stones_on_board()) {
                    // Warn user about losing undo history
                    const confirmed = await showConfirmationWithOptOut(
                        'Entering edit mode will clear your undo history. Are you sure you want to continue?',
                        confirmationPrefs.editMode
                    );
                    if (!confirmed) {
                        return;
                    }
                }

                editMode = !editMode;
                if (editMode) {
                    button.textContent = '‚úèÔ∏è Edit Mode';
                    button.style.backgroundColor = '#4CAF50';
                    button.style.color = 'white';
                } else {
                    button.textContent = '‚úèÔ∏è Edit Mode';
                    button.style.backgroundColor = '';
                    button.style.color = '';
                }

                console.log('Edit mode:', editMode ? 'ON' : 'OFF');
            });
            */

            // Screenshot button
            document.getElementById('screenshot-btn').addEventListener('click', async () => {
                const button = document.getElementById('screenshot-btn');
                const originalText = button.textContent;

                try {
                    button.textContent = 'üì∑ Capturing...';
                    button.disabled = true;

                    // Create a temporary canvas to capture just the board
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');

                    // Set canvas size to match the actual board
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;

                    // Copy the current board state to the temporary canvas
                    tempCtx.drawImage(canvas, 0, 0);

                    // Convert canvas to data URL for display
                    const imageDataUrl = tempCanvas.toDataURL('image/png');

                    // Create modal dialog
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                        font-family: Arial, sans-serif;
                    `;

                    const modalContent = document.createElement('div');
                    modalContent.style.cssText = `
                        background: white;
                        padding: 20px;
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                        max-width: 90vw;
                        max-height: 90vh;
                        text-align: center;
                        overflow: auto;
                    `;

                    const title = document.createElement('h3');
                    title.textContent = 'Board Screenshot';
                    title.style.cssText = `
                        margin: 0 0 15px 0;
                        color: #333;
                        font-size: 18px;
                    `;

                    const screenshotImg = document.createElement('img');
                    screenshotImg.src = imageDataUrl;
                    screenshotImg.style.cssText = `
                        max-width: 100%;
                        max-height: 60vh;
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        margin-bottom: 20px;
                        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                    `;

                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = `
                        display: flex;
                        gap: 12px;
                        justify-content: center;
                        flex-wrap: wrap;
                    `;

                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'üìã Copy to Clipboard';
                    copyButton.style.cssText = `
                        padding: 10px 20px;
                        background: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                    `;

                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'üíæ Save';
                    saveButton.style.cssText = `
                        padding: 10px 20px;
                        background: #2196F3;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                    `;

                    const closeButton = document.createElement('button');
                    closeButton.textContent = '‚úï Close';
                    closeButton.style.cssText = `
                        padding: 10px 20px;
                        background: #757575;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                    `;

                    // Button hover effects
                    [copyButton, saveButton, closeButton].forEach(btn => {
                        btn.addEventListener('mouseenter', () => {
                            btn.style.opacity = '0.9';
                            btn.style.transform = 'translateY(-1px)';
                        });
                        btn.addEventListener('mouseleave', () => {
                            btn.style.opacity = '1';
                            btn.style.transform = 'translateY(0)';
                        });
                    });

                    // Copy to clipboard functionality
                    copyButton.addEventListener('click', async () => {
                        const originalCopyText = copyButton.textContent;
                        try {
                            copyButton.textContent = 'üìã Copying...';
                            copyButton.disabled = true;

                            tempCanvas.toBlob(async (blob) => {
                                try {
                                    await navigator.clipboard.write([
                                        new ClipboardItem({ 'image/png': blob })
                                    ]);
                                    copyButton.textContent = '‚úÖ Copied!';
                                    setTimeout(() => {
                                        copyButton.textContent = originalCopyText;
                                        copyButton.disabled = false;
                                    }, 2000);
                                } catch (error) {
                                    console.error('Failed to copy to clipboard:', error);
                                    copyButton.textContent = '‚ùå Copy Failed';
                                    setTimeout(() => {
                                        copyButton.textContent = originalCopyText;
                                        copyButton.disabled = false;
                                    }, 2000);
                                }
                            }, 'image/png');
                        } catch (error) {
                            console.error('Error copying to clipboard:', error);
                            copyButton.textContent = '‚ùå Error';
                            setTimeout(() => {
                                copyButton.textContent = originalCopyText;
                                copyButton.disabled = false;
                            }, 2000);
                        }
                    });

                    // Save to disk functionality
                    saveButton.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `go-board-${new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-')}.png`;
                        link.href = imageDataUrl;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        const originalSaveText = saveButton.textContent;
                        saveButton.textContent = '‚úÖ Saved!';
                        setTimeout(() => {
                            saveButton.textContent = originalSaveText;
                        }, 2000);
                    });

                    // Close modal functionality
                    const closeModal = () => {
                        document.body.removeChild(modal);
                    };

                    closeButton.addEventListener('click', closeModal);

                    // Close on backdrop click
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            closeModal();
                        }
                    });

                    // Close on Escape key
                    const handleEscape = (e) => {
                        if (e.key === 'Escape') {
                            closeModal();
                            document.removeEventListener('keydown', handleEscape);
                        }
                    };
                    document.addEventListener('keydown', handleEscape);

                    // Assemble modal
                    buttonContainer.appendChild(copyButton);
                    buttonContainer.appendChild(saveButton);
                    buttonContainer.appendChild(closeButton);

                    modalContent.appendChild(title);
                    modalContent.appendChild(screenshotImg);
                    modalContent.appendChild(buttonContainer);
                    modal.appendChild(modalContent);

                    document.body.appendChild(modal);

                    // Reset button state
                    button.textContent = originalText;
                    button.disabled = false;

                } catch (error) {
                    console.error('Error creating screenshot:', error);
                    button.textContent = '‚ùå Error';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                }
            });

            // Move numbers toggle button
            document.getElementById('move-numbers-btn').addEventListener('click', () => {
                showMoveNumbers = !showMoveNumbers;
                const button = document.getElementById('move-numbers-btn');
                button.textContent = showMoveNumbers ? 'üî¢ Move Numbers: ON' : 'üî¢ Move Numbers: OFF';

                // Save preference
                saveUserPreference(userPrefs.moveNumbersEnabled, showMoveNumbers);

                // Redraw board to show/hide move numbers
                if (game) {
                    drawBoard();
                }

                console.log('Move numbers:', showMoveNumbers ? 'ON' : 'OFF');
            });

            // Settings modal functionality
            const settingsModal = document.getElementById('settings-modal');
            const settingsBtn = document.getElementById('settings-btn');
            const settingsClose = document.getElementById('settings-close');

            // Open settings modal
            settingsBtn.addEventListener('click', () => {
                settingsModal.classList.add('show');
            });

            // Close settings modal
            const closeSettings = () => {
                settingsModal.classList.remove('show');
            };

            settingsClose.addEventListener('click', closeSettings);

            // Close modal when clicking outside
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    closeSettings();
                }
            });

            // Close modal with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (settingsModal.classList.contains('show')) {
                        closeSettings();
                    }
                    if (newGameModal.classList.contains('show')) {
                        closeNewGame();
                    }
                }
            });

            // Handle window resize and orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce resize events
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 100);
            });

            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                // Wait a bit for the orientation to fully change
                setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 250);
            });
        }

        function updateUndoRedoButtons() {
            if (!game) {
                document.getElementById('undo-btn').disabled = true;
                document.getElementById('redo-btn').disabled = true;
                return;
            }

            document.getElementById('undo-btn').disabled = !game.can_undo();
            document.getElementById('redo-btn').disabled = !game.can_redo();
        }

        // Update URL with current game state
        function updateUrl() {
            if (!game || suppressUrlUpdate) return;

            try {
                const state = game.serialize_state();
                const url = new URL(window.location);
                url.searchParams.set('state', state);
                window.history.replaceState(null, '', url);

                // Also save to localStorage for automatic restoration
                saveGameStateToLocalStorage();
            } catch (error) {
                console.warn('Failed to update URL:', error);
            }
        }

        // Load game state from URL
        function loadStateFromUrl() {
            const url = new URL(window.location);
            const stateParam = url.searchParams.get('state');

            if (stateParam && game) {
                suppressUrlUpdate = true;
                try {
                    if (game.deserialize_state(stateParam)) {
                        console.log('Successfully loaded state from URL');
                        return true;
                    } else {
                        console.warn('Failed to deserialize state from URL');
                    }
                } catch (error) {
                    console.warn('Error loading state from URL:', error);
                } finally {
                    suppressUrlUpdate = false;
                }
            }
            return false;
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', () => {
            if (game && loadStateFromUrl()) {
                drawBoard();
                updateUndoRedoButtons();
            }
        });

        // Helper function to draw a small stone for status display
        function drawSmallStone(ctx, x, y, radius, color) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);

            if (color === 'black') {
                ctx.fillStyle = '#000';
                ctx.fill();
            } else {
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Helper function to draw game status above the board
        function drawGameStatus(ctx, canvasWidth, boardTopY, cellSize, boardLeftX, boardWidth) {
            if (!game) return;

            const currentPlayer = game.get_current_player();
            const blackCaptures = game.get_black_captures();
            const whiteCaptures = game.get_white_captures();

            // Calculate positioning - ensure status doesn't get clipped off top
            const fontSize = Math.max(12, cellSize * 0.3);
            const stoneRadius = Math.max(6, cellSize * 0.15);
            const minTopMargin = 5; // Minimum margin from top of canvas
            const idealOffset = 25; // Ideal distance above board

            // Choose the position that keeps the status visible
            const statusY = Math.max(
                fontSize + minTopMargin, // Ensure text doesn't clip off top
                boardTopY - idealOffset   // Ideal position above board
            );

            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = '#000';

            // LEFT SIDE: Draw "Next:" indicator
            ctx.textAlign = 'left';
            const nextText = 'Next:';
            let leftX = boardLeftX;

            // Draw "Next:" text
            ctx.fillText(nextText, leftX, statusY);
            leftX += ctx.measureText(nextText).width + 10;

            // Draw next player stone
            const nextPlayerColor = currentPlayer === 1 ? 'black' : 'white';
            drawSmallStone(ctx, leftX + stoneRadius, statusY - fontSize / 4, stoneRadius, nextPlayerColor);

            // RIGHT SIDE: Draw capture scores
            ctx.fillStyle = '#000';
            ctx.textAlign = 'right';
            const boardRightX = boardLeftX + boardWidth;
            let rightX = boardRightX;

            // Draw the number of black stones which were captured by white
            const blackText = `${whiteCaptures}`;
            ctx.fillText(blackText, rightX, statusY);
            rightX -= ctx.measureText(blackText).width + 5;

            // Draw black stone
            drawSmallStone(ctx, rightX - stoneRadius, statusY - fontSize / 4, stoneRadius, 'black');
            rightX -= (stoneRadius * 2) + 15;

            // Draw the number of white stones which were captured by black
            const whiteText = `${blackCaptures}`;
            ctx.fillText(whiteText, rightX, statusY);
            rightX -= ctx.measureText(whiteText).width + 5;

            // Draw white stone
            drawSmallStone(ctx, rightX - stoneRadius, statusY - fontSize / 4, stoneRadius, 'white');
        } function drawBoard() {
            if (!game) return;

            const ctx = canvas.getContext('2d');

            // Get the actual display size (accounting for device pixel ratio scaling)
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Clear canvas
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            // Draw grid lines with crisp lines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Draw horizontal lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const y = Math.round(offsetY + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(Math.round(offsetX) + 0.5, y);
                ctx.lineTo(Math.round(offsetX + boardPixelSize) + 0.5, y);
                ctx.stroke();
            }

            // Draw vertical lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const x = Math.round(offsetX + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(x, Math.round(offsetY) + 0.5);
                ctx.lineTo(x, Math.round(offsetY + boardPixelSize) + 0.5);
                ctx.stroke();
            }

            // Draw star points based on board size
            let starPoints = [];
            if (currentBoardSize === 19) {
                starPoints = [
                    [3, 3], [9, 3], [15, 3],
                    [3, 9], [9, 9], [15, 9],
                    [3, 15], [9, 15], [15, 15]
                ];
            } else if (currentBoardSize === 13) {
                starPoints = [
                    [3, 3], [3, 9], [9, 3], [9, 9], // corners
                    [6, 6] // center
                ];
            } else if (currentBoardSize === 9) {
                starPoints = [
                    [2, 2], [2, 6], [6, 2], [6, 6], // corners
                    [4, 4] // center
                ];
            }

            ctx.fillStyle = '#000';
            const starRadius = Math.max(2, cellSize * 0.08); // Scale star point size with board
            for (let [sx, sy] of starPoints) {
                // Use the same positioning logic as grid lines for perfect alignment
                const x = Math.round(offsetX + sx * cellSize) + 0.5;
                const y = Math.round(offsetY + sy * cellSize) + 0.5;
                ctx.beginPath();
                ctx.arc(x, y, starRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw stones with high quality
            for (let y = 0; y < currentBoardSize; y++) {
                for (let x = 0; x < currentBoardSize; x++) {
                    const state = game.get_board_state(x, y);
                    if (state !== 0) {
                        // Use the same positioning logic as grid lines for perfect alignment
                        const centerX = Math.round(offsetX + x * cellSize) + 0.5;
                        const centerY = Math.round(offsetY + y * cellSize) + 0.5;
                        const radius = cellSize * 0.4;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                        if (state === 1) { // Black
                            ctx.fillStyle = '#000';
                            ctx.fill();
                        } else { // White
                            ctx.fillStyle = '#FFF';
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = Math.max(1, cellSize * 0.05); // Scale stroke width
                            ctx.stroke();
                        }

                        // Draw move number if enabled
                        if (showMoveNumbers) {
                            const moveNumber = game.get_move_number(x, y);
                            if (moveNumber > 0) {
                                // Set text properties
                                const fontSize = Math.max(8, cellSize * 0.25);
                                ctx.font = `bold ${fontSize}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';

                                // Use contrasting text color
                                ctx.fillStyle = state === 1 ? '#FFF' : '#000'; // White text on black stones, black text on white stones

                                // Draw the move number
                                ctx.fillText(moveNumber.toString(), centerX, centerY);
                            }
                        }
                    }
                }
            }

            // Draw hover preview stone
            if (hoverPosition && isValidBoardPosition(hoverPosition.x, hoverPosition.y)) {
                // Use the same positioning logic as grid lines for perfect alignment
                const centerX = Math.round(offsetX + hoverPosition.x * cellSize) + 0.5;
                const centerY = Math.round(offsetY + hoverPosition.y * cellSize) + 0.5;
                const radius = cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                if (editMode) {
                    // Edit mode: show next state in cycle
                    const currentState = game.get_board_state(hoverPosition.x, hoverPosition.y);
                    const nextState = (currentState + 1) % 3; // Cycle: Empty -> Black -> White -> Empty

                    if (nextState === 1) { // Next is Black
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else if (nextState === 2) { // Next is White
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    } else if (nextState === 0 && currentState !== 0) {
                        // Next state is Empty and current state is not empty - show red X to indicate removal
                        const xSize = radius * 0.6; // Size of the X
                        const xOffset = xSize * 0.7; // Distance from center to X endpoints

                        ctx.strokeStyle = '#FF4444'; // Bright red
                        ctx.lineWidth = Math.max(3, cellSize * 0.08); // Thick X
                        ctx.lineCap = 'round'; // Rounded line ends

                        // Draw X (two diagonal lines)
                        ctx.beginPath();
                        ctx.moveTo(centerX - xOffset, centerY - xOffset);
                        ctx.lineTo(centerX + xOffset, centerY + xOffset);
                        ctx.moveTo(centerX + xOffset, centerY - xOffset);
                        ctx.lineTo(centerX - xOffset, centerY + xOffset);
                        ctx.stroke();

                        // Add a subtle red circle background for better visibility
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius * 0.8, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 68, 68, 0.15)'; // Very light red background
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)'; // Light red border
                        ctx.lineWidth = Math.max(1, cellSize * 0.02);
                        ctx.stroke();
                    }
                    // If nextState === 0 and currentState === 0 (empty), don't draw anything for hover
                } else {
                    // Normal game mode: show current player's stone
                    const currentPlayer = game.get_current_player();

                    if (currentPlayer === 1) { // Black preview
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        // Add a subtle border to make it more visible
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else { // White preview
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Subtle border
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    }
                }
            }

            // Highlight the most recent move
            const lastMove = game.get_last_move();
            if (lastMove && lastMove.length === 2) {
                const lastX = lastMove[0];
                const lastY = lastMove[1];
                // Use the same positioning logic as grid lines for perfect alignment
                const centerX = Math.round(offsetX + lastX * cellSize) + 0.5;
                const centerY = Math.round(offsetY + lastY * cellSize) + 0.5;
                const highlightRadius = cellSize * 0.3;

                // Draw a colored ring around the last move
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#FF6B6B'; // Red highlight color
                ctx.lineWidth = Math.max(2, cellSize * 0.08); // Thick highlight ring
                ctx.stroke();

                // Add a subtle inner glow effect
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius * 0.7, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)'; // Semi-transparent red
                ctx.lineWidth = Math.max(1, cellSize * 0.04);
                ctx.stroke();
            }

            // Draw game status above the board
            drawGameStatus(ctx, displayWidth, offsetY, cellSize, offsetX, boardPixelSize);
        }

        // Start the game
        initGame();
    </script>
</body>

</html>
