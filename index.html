<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Go</title>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Prevent zoom on double tap in iOS */
            touch-action: manipulation;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            padding: 15px 5px 5px 5px;
            gap: 5px;
        }

        /* Main game area - takes most of the space */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
            /* Important for flex sizing */
        }

        /* Responsive canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: min(95vmin, 90vw);
            max-height: min(95vmin, 90vw);
            aspect-ratio: 1;
        }

        #game-canvas {
            border: 2px solid #8B4513;
            background-color: #DEB887;
            cursor: pointer;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
            /* Prevent canvas selection on mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Compact game status under the board */
        .game-status {
            margin-top: 8px;
            text-align: center;
            font-size: 14px;
        }

        .game-status #current-player {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        .game-status #score-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .game-status #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .controls {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 5px;
            max-height: 25vh;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 12px;
            color: #666;
        }

        .board-size-controls select {
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-width: 80px;
            min-height: 32px;
        }

        /* Primary button controls container - for most used actions */
        .primary-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
        }

        .primary-controls button {
            padding: 12px 16px;
            font-size: 16px;
            font-weight: 700;
            min-height: 44px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Secondary controls container - for less frequently used actions */
        .secondary-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .secondary-button-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 6px;
            align-items: center;
        }

        /* Single button row for actions like sound toggle */
        .secondary-button-row:has(button:only-child),
        .single-button-row {
            grid-template-columns: 1fr;
            justify-items: center;
        }

        .tertiary-button-row {
            display: grid;
            grid-template-columns: auto auto auto;
            gap: 6px;
            align-items: center;
        }


        .secondary-button-row select {
            padding: 8px 10px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-height: 36px;
            text-align: center;
        }

        .secondary-controls button {
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 36px;
            background-color: #6c757d;
            opacity: 0.85;
        }

        .secondary-controls button:hover {
            background-color: #5a6268;
            opacity: 1;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 14px;
            color: #666;
        }

        .board-size-controls select {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: white;
            min-width: 100px;
            min-height: 36px;
        }

        button {
            padding: 15px 20px;
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            /* Improve touch targets */
            min-height: 48px;
            min-width: 120px;
            /* Prevent button text selection */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Add touch feedback */
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            background-color: #3d8b40;
        }

        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            background-color: #cccccc;
            transform: none;
        }



        #current-player {
            font-size: 14px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        #score-display {
            display: flex;
            justify-content: space-around;
            margin-top: 6px;
            flex-wrap: wrap;
            gap: 8px;
        }

        #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        /* Mobile and tablet optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 20px 3px 3px 3px;
                gap: 3px;
            }

            .game-area {
                margin-top: 10px;
            }

            .canvas-container {
                max-width: min(92vmin, 95vw);
                max-height: min(92vmin, 95vw);
            }

            .primary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 40px;
            }

            .secondary-controls {
                padding: 6px;
                gap: 4px;
            }

            .secondary-controls button {
                padding: 6px 8px;
                font-size: 12px;
                min-height: 32px;
            }

            .board-size-controls select {
                min-width: 70px;
                min-height: 28px;
                font-size: 11px;
            }

            #current-player {
                font-size: 12px;
                margin: 2px 0;
            }

            #score-display div {
                padding: 3px 6px;
                font-size: 11px;
                min-width: 80px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .container {
                padding: 15px 2px 2px 2px;
                gap: 2px;
            }

            .game-area {
                margin-top: 8px;
            }

            .primary-controls {
                gap: 4px;
            }

            .primary-controls button {
                padding: 8px 10px;
                font-size: 13px;
                min-height: 36px;
            }

            .secondary-controls {
                padding: 4px;
                gap: 3px;
            }

            .secondary-button-row {
                grid-template-columns: 1fr;
                gap: 3px;
            }

            .secondary-controls button {
                padding: 5px 6px;
                font-size: 11px;
                min-height: 28px;
            }

            #score-display {
                flex-direction: column;
                gap: 4px;
            }
        }

        /* Wide screen layout (desktop/landscape tablets) - side-by-side layout */
        @media (min-aspect-ratio: 4/3) and (min-width: 768px) {
            .container {
                flex-direction: row;
                padding: 8px;
                gap: 16px;
                align-items: center;
            }

            .game-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .canvas-container {
                width: 100%;
                height: 100%;
                max-width: min(85vh, calc(100vw - 250px));
                max-height: min(85vh, calc(100vw - 250px));
            }

            .controls {
                flex-shrink: 0;
                width: auto;
                min-width: 220px;
                max-height: 85vh;
                gap: 12px;
                display: flex;
                flex-direction: column;
                justify-content: center;
                overflow-y: auto;
                padding: 8px;
            }

            .primary-controls {
                gap: 12px;
            }

            .primary-controls button {
                padding: 14px 18px;
                font-size: 16px;
                min-height: 48px;
                min-width: auto;
                width: 100%;
                white-space: nowrap;
            }

            .secondary-controls {
                padding: 12px;
                gap: 8px;
            }

            .secondary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 38px;
                min-width: auto;
                white-space: nowrap;
            }

            .secondary-button-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                gap: 8px;
                align-items: center;
            }

            .secondary-button-row select {
                padding: 10px 12px;
                font-size: 14px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background-color: white;
                min-height: 38px;
            }

            .secondary-button-row button {
                flex: 1;
            }

            #current-player {
                font-size: 15px;
                margin: 6px 0;
            }

            #score-display {
                flex-direction: row;
                gap: 10px;
            }

            #score-display div {
                padding: 6px 10px;
                font-size: 13px;
                min-width: 120px;
            }
        }

        /* Mobile landscape (smaller screens) - compact horizontal layout */
        @media (max-height: 600px) and (orientation: landscape) and (max-width: 767px) {
            .container {
                flex-direction: row;
                padding: 3px;
                gap: 8px;
            }

            .game-area {
                flex: 1;
            }

            .controls {
                flex-shrink: 0;
                width: 200px;
                max-height: none;
                margin-top: 8px;
            }




        }
    </style>
</head>

<body>
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="game-canvas" width="600" height="600"></canvas>
            </div>
            <!-- Compact game status directly under the board -->
            <div class="game-status">
                <div id="current-player">Current Player: Black</div>
                <div id="score-display">
                    <div>Black Captures: <span id="black-score">0</span></div>
                    <div>White Captures: <span id="white-score">0</span></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <!-- Primary game controls - most frequently used -->
            <div class="primary-controls">
                <button id="undo-btn" disabled>Undo</button>
                <button id="redo-btn" disabled>Redo</button>
                <button id="pass-btn">Pass</button>
            </div>

            <!-- Secondary controls - less frequently used -->
            <div class="secondary-controls">
                <div class="secondary-button-row">
                    <button id="new-game-btn">New Game</button>
                    <select id="board-size">
                        <option value="9">9√ó9</option>
                        <option value="13">13√ó13</option>
                        <option value="19" selected>19√ó19</option>
                    </select>
                    <button id="copy-url-btn">Copy Game State</button>
                </div>
                <div class="tertiary-button-row">
                    <button id="sound-toggle-btn">üîä Sound: ON</button>
                    <button id="wake-lock-btn">üí° Prevent sleep: OFF</button>
                    <button id="edit-mode-btn">‚úèÔ∏è Edit Mode: OFF</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { GoGame } from './pkg/rugo.js';

        let game = null;
        const canvas = document.getElementById('game-canvas');
        const currentPlayerText = document.getElementById('current-player');
        let suppressUrlUpdate = false; // Flag to prevent infinite loops
        let eventListenersSetup = false; // Flag to prevent duplicate event listeners
        let hoverPosition = null; // Track mouse position for hover preview
        let editMode = false; // Track whether we're in edit mode
        let isDragging = false; // Track if we're currently dragging in edit mode
        let dragState = null; // The state to apply while dragging (0, 1, or 2)

        // Sound system for game audio feedback
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.volume = 0.3; // Keep sounds subtle
                this.initAudioContext();
            }

            async initAudioContext() {
                try {
                    // Create audio context on first user interaction
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Resume context if it's suspended (required for some browsers)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                } catch (error) {
                    console.warn('Audio not supported:', error);
                    this.enabled = false;
                }
            }

            async ensureAudioContext() {
                if (!this.audioContext) {
                    await this.initAudioContext();
                }
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            // Create a bright, sharp tap sound like stone on wood with subtle randomness
            async playTapSound() {
                if (!this.enabled || !this.audioContext) return;

                try {
                    await this.ensureAudioContext();

                    // Add subtle randomness for natural variation
                    const randomVariation = () => 0.85 + Math.random() * 0.3; // ¬±15% variation
                    const pitchVariation = () => 0.9 + Math.random() * 0.2; // ¬±10% pitch variation
                    const timingVariation = () => 0.8 + Math.random() * 0.4; // ¬±20% timing variation

                    // Create multiple oscillators for a rich, full-spectrum sound
                    const oscillator1 = this.audioContext.createOscillator(); // Primary mid-range
                    const oscillator2 = this.audioContext.createOscillator(); // High harmonic
                    const oscillator3 = this.audioContext.createOscillator(); // Low body
                    const gainNode1 = this.audioContext.createGain();
                    const gainNode2 = this.audioContext.createGain();
                    const gainNode3 = this.audioContext.createGain();
                    const masterGain = this.audioContext.createGain();

                    // Connect nodes
                    oscillator1.connect(gainNode1);
                    oscillator2.connect(gainNode2);
                    oscillator3.connect(gainNode3);
                    gainNode1.connect(masterGain);
                    gainNode2.connect(masterGain);
                    gainNode3.connect(masterGain);
                    masterGain.connect(this.audioContext.destination);

                    // Primary tap sound with slight pitch variation
                    const baseFreq1 = 1200 * pitchVariation();
                    const endFreq1 = 400 * pitchVariation();
                    oscillator1.frequency.setValueAtTime(baseFreq1, this.audioContext.currentTime);
                    oscillator1.frequency.exponentialRampToValueAtTime(endFreq1, this.audioContext.currentTime + 0.008 * timingVariation());

                    // Secondary harmonic with variation
                    const baseFreq2 = 2400 * pitchVariation();
                    const endFreq2 = 800 * pitchVariation();
                    oscillator2.frequency.setValueAtTime(baseFreq2, this.audioContext.currentTime);
                    oscillator2.frequency.exponentialRampToValueAtTime(endFreq2, this.audioContext.currentTime + 0.005 * timingVariation());

                    // Low frequency component with variation
                    const baseFreq3 = 200 * pitchVariation();
                    const endFreq3 = 80 * pitchVariation();
                    oscillator3.frequency.setValueAtTime(baseFreq3, this.audioContext.currentTime);
                    oscillator3.frequency.exponentialRampToValueAtTime(endFreq3, this.audioContext.currentTime + 0.012 * timingVariation());

                    // Sharp attack envelope for primary sound with volume variation
                    gainNode1.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode1.gain.linearRampToValueAtTime(this.volume * 0.8 * randomVariation(), this.audioContext.currentTime + 0.0005 * timingVariation());
                    gainNode1.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.04 * timingVariation());

                    // Brighter harmonic with variation
                    gainNode2.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode2.gain.linearRampToValueAtTime(this.volume * 0.4 * randomVariation(), this.audioContext.currentTime + 0.0003 * timingVariation());
                    gainNode2.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.02 * timingVariation());

                    // Low frequency body with variation
                    gainNode3.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode3.gain.linearRampToValueAtTime(this.volume * 0.3 * randomVariation(), this.audioContext.currentTime + 0.001 * timingVariation());
                    gainNode3.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.035 * timingVariation());

                    // Master volume control with slight variation
                    masterGain.gain.setValueAtTime(this.volume * randomVariation(), this.audioContext.currentTime);

                    // Play the sound with randomized durations
                    const duration1 = 0.04 * timingVariation();
                    const duration2 = 0.02 * timingVariation();
                    const duration3 = 0.035 * timingVariation();

                    oscillator1.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + duration1);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator2.stop(this.audioContext.currentTime + duration2);
                    oscillator3.start(this.audioContext.currentTime);
                    oscillator3.stop(this.audioContext.currentTime + duration3);

                } catch (error) {
                    console.warn('Error playing sound:', error);
                }
            }

            // Toggle sound on/off
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }

            // Set volume (0.0 to 1.0)
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }
        }

        // Wake lock system to prevent screen from dimming/sleeping
        class WakeLockSystem {
            constructor() {
                this.wakeLock = null;
                this.enabled = false;
                this.supported = 'wakeLock' in navigator;

                // Handle visibility change to re-acquire wake lock
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && this.enabled) {
                        this.requestWakeLock();
                    }
                });
            }

            async requestWakeLock() {
                if (!this.supported) {
                    console.warn('Wake Lock API not supported');
                    return false;
                }

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired - screen will stay on');

                    // Listen for wake lock release
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake lock released');
                    });

                    return true;
                } catch (error) {
                    console.warn('Failed to acquire wake lock:', error);
                    return false;
                }
            }

            async releaseWakeLock() {
                if (this.wakeLock) {
                    try {
                        await this.wakeLock.release();
                        this.wakeLock = null;
                        console.log('Wake lock manually released');
                    } catch (error) {
                        console.warn('Error releasing wake lock:', error);
                    }
                }
            }

            async toggle() {
                if (this.enabled) {
                    // Turn off wake lock
                    this.enabled = false;
                    await this.releaseWakeLock();
                    return false;
                } else {
                    // Turn on wake lock
                    this.enabled = true;
                    const success = await this.requestWakeLock();
                    if (!success) {
                        this.enabled = false;
                    }
                    return this.enabled;
                }
            }

            isSupported() {
                return this.supported;
            }

            isEnabled() {
                return this.enabled;
            }
        }

        // Initialize sound system
        const soundSystem = new SoundSystem();

        // Initialize wake lock system
        const wakeLockSystem = new WakeLockSystem();

        // Helper function to get board coordinates from mouse/touch event
        function getBoardPositionFromEvent(event) {
            if (!game) return null;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Handle both touch and mouse events
            if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    return null;
                }
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            // Calculate coordinates relative to the displayed canvas size
            // Account for device pixel ratio scaling
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            const canvasX = (clientX - rect.left) * (displayWidth / rect.width);
            const canvasY = (clientY - rect.top) * (displayHeight / rect.height);

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Calculate board layout (same as in drawBoard)
            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Convert canvas coordinates to board coordinates
            const boardX = Math.round((canvasX - offsetX) / cellSize);
            const boardY = Math.round((canvasY - offsetY) / cellSize);

            return { x: boardX, y: boardY };
        }

        // Helper function to check if board position is valid for placing a stone
        function isValidBoardPosition(boardX, boardY) {
            if (!game) return false;

            const currentBoardSize = game.get_board_size();

            // Check if position is within board bounds
            if (boardX < 0 || boardX >= currentBoardSize || boardY < 0 || boardY >= currentBoardSize) {
                return false;
            }

            // In edit mode, allow clicking on any position (empty or occupied)
            if (editMode) {
                return true;
            }

            // In normal game mode, check if position is empty
            return game.get_board_state(boardX, boardY) === 0;
        }

        async function initGame() {
            try {
                // Initialize the wasm module
                await init();

                // Get selected board size
                const boardSize = parseInt(document.getElementById('board-size').value);

                // Set up responsive canvas sizing
                setupResponsiveCanvas();

                // Create game instance with selected size
                game = GoGame.new_with_size(canvas, boardSize);

                // Set up event listeners (only once)
                if (!eventListenersSetup) {
                    setupEventListeners();
                }

                // Try to load state from URL, otherwise draw fresh board
                if (!loadStateFromUrl()) {
                    updateUrl(); // Set initial state in URL
                }
                drawBoard();
                updateUndoRedoButtons();

            } catch (error) {
                console.error('Failed to initialize game:', error);
            }
        }

        function setupResponsiveCanvas() {
            const container = document.querySelector('.canvas-container');
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);

            // Get device pixel ratio for high-DPI displays
            const devicePixelRatio = window.devicePixelRatio || 1;

            // Calculate the actual pixel size we want to render at
            const displaySize = Math.floor(size);
            const renderSize = Math.floor(displaySize * devicePixelRatio);

            // Set canvas internal dimensions to high resolution
            canvas.width = renderSize;
            canvas.height = renderSize;

            // Set CSS size to display size
            canvas.style.width = displaySize + 'px';
            canvas.style.height = displaySize + 'px';

            // Scale the context to match device pixel ratio
            const ctx = canvas.getContext('2d');
            ctx.scale(devicePixelRatio, devicePixelRatio);

            console.log(`Canvas setup: Display ${displaySize}px, Render ${renderSize}px, DPR ${devicePixelRatio}`);
        }

        function setupEventListeners() {
            if (eventListenersSetup) return; // Prevent duplicate listeners
            eventListenersSetup = true;

            // Helper function to handle board interactions
            function handleBoardInteraction(event) {
                if (!game) return;

                // Prevent default touch behaviors
                event.preventDefault();

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if click is within board bounds and position is valid
                if (isValidBoardPosition(boardX, boardY)) {
                    try {
                        if (editMode) {
                            // Edit mode: cycle through states (Empty -> Black -> White -> Empty)
                            const currentState = game.get_board_state(boardX, boardY);

                            // Cycle: 0 (Empty) -> 1 (Black) -> 2 (White) -> 0 (Empty)
                            const nextState = (currentState + 1) % 3;

                            console.log(`Edit mode: position (${boardX}, ${boardY}), current state: ${currentState}, next state: ${nextState}`);

                            const result = game.set_board_position(boardX, boardY, nextState);
                            console.log(`Set position result: ${result}`);

                            if (result === "Position set successfully") {
                                // Start dragging with this state
                                isDragging = true;
                                dragState = nextState;

                                // Play sound effect for edit action
                                soundSystem.playTapSound();

                                // Clear hover position after edit
                                hoverPosition = null;

                                drawBoard();
                                // Don't update URL here - wait until drag ends
                            } else {
                                console.log('Edit not allowed:', result);
                            }
                        } else {
                            // Normal game mode
                            const result = game.handle_board_click(boardX, boardY);
                            if (result === "Move successful") {
                                // Play sound effect for successful stone placement
                                soundSystem.playTapSound();

                                // Clear hover position after successful move
                                hoverPosition = null;

                                drawBoard();
                                updateUndoRedoButtons();
                                updateUrl();
                            } else {
                                // Log error message
                                console.log('Move not allowed:', result);
                            }
                        }
                    } catch (error) {
                        console.error('Board interaction error:', error);
                    }
                }
            }

            // Helper function to handle dragging in edit mode
            function handleEditDrag(event) {
                if (!game || !editMode || !isDragging || dragState === null) return;

                const boardPos = getBoardPositionFromEvent(event);
                if (!boardPos) return;

                const { x: boardX, y: boardY } = boardPos;

                // Check if position is within board bounds
                if (isValidBoardPosition(boardX, boardY)) {
                    // Only apply the drag state if the current position doesn't already have it
                    const currentState = game.get_board_state(boardX, boardY);
                    if (currentState !== dragState) {
                        const result = game.set_board_position(boardX, boardY, dragState);
                        if (result === "Position set successfully") {
                            drawBoard();
                        }
                    }
                }
            }

            // Canvas mousedown handler for drag start
            canvas.addEventListener('mousedown', (event) => {
                if (editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Canvas mouseup handler for drag end
            canvas.addEventListener('mouseup', () => {
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL once at the end of drag
                }
            });

            // Canvas click handler for non-edit mode
            canvas.addEventListener('click', (event) => {
                if (!editMode) {
                    handleBoardInteraction(event);
                }
            });

            // Mouse move handler for hover preview and dragging
            canvas.addEventListener('mousemove', (event) => {
                if (!game) return;

                // Handle dragging in edit mode
                if (editMode && isDragging) {
                    handleEditDrag(event);
                }

                // Handle hover preview
                const boardPos = getBoardPositionFromEvent(event);
                if (boardPos && isValidBoardPosition(boardPos.x, boardPos.y)) {
                    hoverPosition = boardPos;
                } else {
                    hoverPosition = null;
                }

                // Only redraw for hover if we're not dragging (to avoid excessive redraws)
                if (!isDragging) {
                    drawBoard(); // Redraw to show/hide hover preview
                }
            });

            // Mouse leave handler to clear hover preview and stop dragging
            canvas.addEventListener('mouseleave', () => {
                hoverPosition = null;
                if (editMode && isDragging) {
                    isDragging = false;
                    dragState = null;
                    updateUrl(); // Update URL when drag ends
                }
                drawBoard();
            });

            // Touch event handlers for better mobile support with drag functionality
            canvas.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // In edit mode, start dragging immediately
                    handleBoardInteraction(event);
                } else {
                    // Store the touch for potential tap detection in normal mode
                    canvas._touchStartTime = Date.now();
                    canvas._touchStartPos = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                }
            });

            canvas.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode && isDragging) {
                    // Handle dragging in edit mode
                    handleEditDrag(event);
                }
            });

            canvas.addEventListener('touchend', (event) => {
                event.preventDefault(); // Prevent scrolling

                if (editMode) {
                    // End dragging in edit mode
                    if (isDragging) {
                        isDragging = false;
                        dragState = null;
                        updateUrl(); // Update URL when drag ends
                    }
                } else {
                    // Handle tap in normal mode
                    if (canvas._touchStartTime && canvas._touchStartPos) {
                        const touchDuration = Date.now() - canvas._touchStartTime;
                        const touch = event.changedTouches[0];
                        const deltaX = Math.abs(touch.clientX - canvas._touchStartPos.x);
                        const deltaY = Math.abs(touch.clientY - canvas._touchStartPos.y);

                        // Consider it a tap if it was quick and didn't move much
                        if (touchDuration < 500 && deltaX < 10 && deltaY < 10) {
                            handleBoardInteraction(event);
                        }
                    }

                    // Clean up
                    delete canvas._touchStartTime;
                    delete canvas._touchStartPos;
                }
            });

            // Prevent context menu on touch devices
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            // Board size selector
            document.getElementById('board-size').addEventListener('change', (event) => {
                // Ask for confirmation before changing board size (which resets the game)
                const confirmed = confirm('Changing the board size will start a new game and lose your current progress. Continue?');
                if (!confirmed) {
                    // Revert the selection to the current board size
                    const currentBoardSize = game ? game.get_board_size() : 19;
                    event.target.value = currentBoardSize.toString();
                    return;
                }

                // Clear URL state when user changes board size manually
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);
                initGame(); // Start new game with selected size
            });

            // New game button
            document.getElementById('new-game-btn').addEventListener('click', () => {
                // Ask for confirmation before starting a new game
                const confirmed = confirm('Start a new game? This will lose your current progress.');
                if (!confirmed) {
                    return;
                }

                // Clear URL state for fresh game
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);

                // Start fresh game
                initGame();
            });

            // Undo button
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (game && game.undo()) {
                    // Play sound effect for undo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Redo button
            document.getElementById('redo-btn').addEventListener('click', () => {
                if (game && game.redo()) {
                    // Play sound effect for redo
                    soundSystem.playTapSound();

                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Pass button
            document.getElementById('pass-btn').addEventListener('click', () => {
                if (game) {
                    try {
                        const result = game.handle_pass();
                        if (result === "Pass successful") {
                            // Play sound effect for pass
                            soundSystem.playTapSound();

                            drawBoard();
                            updateUndoRedoButtons();
                            updateUrl();

                            // Log pass message
                            const player = game.get_current_player() === 1 ? 'White' : 'Black'; // Previous player (who just passed)
                            const previousPlayer = game.get_current_player() === 1 ? 'Black' : 'White';
                            console.log(`${previousPlayer} passes. ${player}'s turn.`);
                        } else {
                            console.log('Pass not allowed:', result);
                        }
                    } catch (error) {
                        console.error('Pass error:', error);
                    }
                }
            });

            // Copy URL button
            document.getElementById('copy-url-btn').addEventListener('click', async () => {
                if (!game) {
                    console.log('No game to copy URL for');
                    return;
                }

                try {
                    // Ensure URL is up to date with current game state
                    updateUrl();

                    // Copy current URL to clipboard
                    await navigator.clipboard.writeText(window.location.href);

                    // Log success message
                    console.log('Game URL copied to clipboard!');
                } catch (error) {
                    console.error('Failed to copy URL:', error);
                    // Fallback for browsers that don't support clipboard API
                    try {
                        // Create a temporary input element
                        const tempInput = document.createElement('input');
                        tempInput.value = window.location.href;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);

                        console.log('Game URL copied to clipboard!');
                    } catch (fallbackError) {
                        console.error('Fallback copy failed:', fallbackError);
                    }
                }
            });

            // Sound toggle button
            document.getElementById('sound-toggle-btn').addEventListener('click', () => {
                const enabled = soundSystem.toggle();
                const button = document.getElementById('sound-toggle-btn');
                if (enabled) {
                    button.textContent = 'üîä Sound: ON';
                    // Play a test sound to confirm it's working
                    soundSystem.playTapSound();
                } else {
                    button.textContent = 'üîá Sound: OFF';
                }
            });

            // Wake lock toggle button
            document.getElementById('wake-lock-btn').addEventListener('click', async () => {
                const button = document.getElementById('wake-lock-btn');

                if (!wakeLockSystem.isSupported()) {
                    button.textContent = '‚ùå Keep Screen On: Not Supported';
                    button.disabled = true;
                    button.hidden = true;
                    console.warn('Wake Lock API not supported on this device/browser');
                    return;
                }

                try {
                    const enabled = await wakeLockSystem.toggle();
                    if (enabled) {
                        button.textContent = 'üí° Prevent Sleep: ON';
                        console.log('Screen will stay on while game is active');
                    } else {
                        button.textContent = 'üí° Prevent Sleep: OFF';
                        console.log('Screen can dim/sleep normally');
                    }
                } catch (error) {
                    console.error('Error toggling wake lock:', error);
                    button.textContent = '‚ùå Prevent Sleep: Error';
                }
            });

            // Edit mode toggle button
            document.getElementById('edit-mode-btn').addEventListener('click', () => {
                const button = document.getElementById('edit-mode-btn');

                if (!editMode && game && game.has_stones_on_board()) {
                    // Warn user about losing undo history
                    const confirmed = confirm(
                        'Entering edit mode will clear your undo history. Are you sure you want to continue?'
                    );
                    if (!confirmed) {
                        return;
                    }
                }

                editMode = !editMode;
                if (editMode) {
                    button.textContent = '‚úèÔ∏è Edit Mode: ON';
                    button.style.backgroundColor = '#4CAF50';
                    button.style.color = 'white';
                } else {
                    button.textContent = '‚úèÔ∏è Edit Mode: OFF';
                    button.style.backgroundColor = '';
                    button.style.color = '';
                }

                console.log('Edit mode:', editMode ? 'ON' : 'OFF');
            });

            // Handle window resize and orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce resize events
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 100);
            });

            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                // Wait a bit for the orientation to fully change
                setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 250);
            });
        }

        function updateUndoRedoButtons() {
            if (!game) {
                document.getElementById('undo-btn').disabled = true;
                document.getElementById('redo-btn').disabled = true;
                return;
            }

            document.getElementById('undo-btn').disabled = !game.can_undo();
            document.getElementById('redo-btn').disabled = !game.can_redo();
        }

        // Update URL with current game state
        function updateUrl() {
            if (!game || suppressUrlUpdate) return;

            try {
                const state = game.serialize_state();
                const url = new URL(window.location);
                url.searchParams.set('state', state);
                window.history.replaceState(null, '', url);
            } catch (error) {
                console.warn('Failed to update URL:', error);
            }
        }

        // Load game state from URL
        function loadStateFromUrl() {
            const url = new URL(window.location);
            const stateParam = url.searchParams.get('state');

            if (stateParam && game) {
                suppressUrlUpdate = true;
                try {
                    if (game.deserialize_state(stateParam)) {
                        console.log('Successfully loaded state from URL');
                        // Update board size selector to match loaded state
                        const boardSize = game.get_board_size();
                        document.getElementById('board-size').value = boardSize.toString();
                        return true;
                    } else {
                        console.warn('Failed to deserialize state from URL');
                    }
                } catch (error) {
                    console.warn('Error loading state from URL:', error);
                } finally {
                    suppressUrlUpdate = false;
                }
            }
            return false;
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', () => {
            if (game && loadStateFromUrl()) {
                drawBoard();
                updateUndoRedoButtons();
            }
        });

        function drawBoard() {
            if (!game) return;

            const ctx = canvas.getContext('2d');

            // Get the actual display size (accounting for device pixel ratio scaling)
            const devicePixelRatio = window.devicePixelRatio || 1;
            const displayWidth = canvas.width / devicePixelRatio;
            const displayHeight = canvas.height / devicePixelRatio;

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Clear canvas
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(0, 0, displayWidth, displayHeight);

            // Draw grid lines with crisp lines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            const cellSize = Math.min(displayWidth, displayHeight) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (displayWidth - boardPixelSize) / 2;
            const offsetY = (displayHeight - boardPixelSize) / 2;

            // Draw horizontal lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const y = Math.round(offsetY + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(Math.round(offsetX) + 0.5, y);
                ctx.lineTo(Math.round(offsetX + boardPixelSize) + 0.5, y);
                ctx.stroke();
            }

            // Draw vertical lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const x = Math.round(offsetX + i * cellSize) + 0.5; // +0.5 for crisp lines
                ctx.beginPath();
                ctx.moveTo(x, Math.round(offsetY) + 0.5);
                ctx.lineTo(x, Math.round(offsetY + boardPixelSize) + 0.5);
                ctx.stroke();
            }

            // Draw star points based on board size
            let starPoints = [];
            if (currentBoardSize === 19) {
                starPoints = [
                    [3, 3], [9, 3], [15, 3],
                    [3, 9], [9, 9], [15, 9],
                    [3, 15], [9, 15], [15, 15]
                ];
            } else if (currentBoardSize === 13) {
                starPoints = [
                    [3, 3], [3, 9], [9, 3], [9, 9], // corners
                    [6, 6] // center
                ];
            } else if (currentBoardSize === 9) {
                starPoints = [
                    [2, 2], [2, 6], [6, 2], [6, 6], // corners
                    [4, 4] // center
                ];
            }

            ctx.fillStyle = '#000';
            const starRadius = Math.max(2, cellSize * 0.08); // Scale star point size with board
            for (let [sx, sy] of starPoints) {
                const x = offsetX + sx * cellSize;
                const y = offsetY + sy * cellSize;
                ctx.beginPath();
                ctx.arc(x, y, starRadius, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw stones with high quality
            for (let y = 0; y < currentBoardSize; y++) {
                for (let x = 0; x < currentBoardSize; x++) {
                    const state = game.get_board_state(x, y);
                    if (state !== 0) {
                        const centerX = offsetX + x * cellSize;
                        const centerY = offsetY + y * cellSize;
                        const radius = cellSize * 0.4;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                        if (state === 1) { // Black
                            ctx.fillStyle = '#000';
                            ctx.fill();
                        } else { // White
                            ctx.fillStyle = '#FFF';
                            ctx.fill();
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = Math.max(1, cellSize * 0.05); // Scale stroke width
                            ctx.stroke();
                        }
                    }
                }
            }

            // Draw hover preview stone
            if (hoverPosition && isValidBoardPosition(hoverPosition.x, hoverPosition.y)) {
                const centerX = offsetX + hoverPosition.x * cellSize;
                const centerY = offsetY + hoverPosition.y * cellSize;
                const radius = cellSize * 0.4;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                if (editMode) {
                    // Edit mode: show next state in cycle
                    const currentState = game.get_board_state(hoverPosition.x, hoverPosition.y);
                    const nextState = (currentState + 1) % 3; // Cycle: Empty -> Black -> White -> Empty

                    if (nextState === 1) { // Next is Black
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else if (nextState === 2) { // Next is White
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    }
                    // If nextState === 0 (Empty), don't draw anything for hover
                } else {
                    // Normal game mode: show current player's stone
                    const currentPlayer = game.get_current_player();

                    if (currentPlayer === 1) { // Black preview
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; // Translucent black
                        ctx.fill();
                        // Add a subtle border to make it more visible
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = Math.max(1, cellSize * 0.03);
                        ctx.stroke();
                    } else { // White preview
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // Translucent white
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Subtle border
                        ctx.lineWidth = Math.max(1, cellSize * 0.05);
                        ctx.stroke();
                    }
                }
            }

            // Highlight the most recent move
            const lastMove = game.get_last_move();
            if (lastMove && lastMove.length === 2) {
                const lastX = lastMove[0];
                const lastY = lastMove[1];
                const centerX = offsetX + lastX * cellSize;
                const centerY = offsetY + lastY * cellSize;
                const highlightRadius = cellSize * 0.3;

                // Draw a colored ring around the last move
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#FF6B6B'; // Red highlight color
                ctx.lineWidth = Math.max(2, cellSize * 0.08); // Thick highlight ring
                ctx.stroke();

                // Add a subtle inner glow effect
                ctx.beginPath();
                ctx.arc(centerX, centerY, highlightRadius * 0.7, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)'; // Semi-transparent red
                ctx.lineWidth = Math.max(1, cellSize * 0.04);
                ctx.stroke();
            }

            // Update current player display
            const player = game.get_current_player();
            currentPlayerText.textContent = `Current Player: ${player === 1 ? 'Black' : 'White'}`;

            // Update capture scores
            document.getElementById('black-score').textContent = game.get_black_captures();
            document.getElementById('white-score').textContent = game.get_white_captures();
        }

        // Start the game
        initGame();
    </script>
</body>

</html>
