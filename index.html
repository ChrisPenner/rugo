<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Go</title>
    <style>
        /* Base styles */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Prevent zoom on double tap in iOS */
            touch-action: manipulation;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            padding: 15px 5px 5px 5px;
            gap: 5px;
        }

        /* Main game area - takes most of the space */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 0;
            /* Important for flex sizing */
        }

        /* Responsive canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: min(95vmin, 90vw);
            max-height: min(95vmin, 90vw);
            aspect-ratio: 1;
        }

        #game-canvas {
            border: 2px solid #8B4513;
            background-color: #DEB887;
            cursor: pointer;
            width: 100%;
            height: 100%;
            display: block;
            margin: auto;
            /* Prevent canvas selection on mobile */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Compact game status under the board */
        .game-status {
            margin-top: 8px;
            text-align: center;
            font-size: 14px;
        }

        .game-status #current-player {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        .game-status #score-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .game-status #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        .controls {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 5px;
            max-height: 25vh;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 12px;
            color: #666;
        }

        .board-size-controls select {
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-width: 80px;
            min-height: 32px;
        }

        /* Primary button controls container - for most used actions */
        .primary-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            width: 100%;
        }

        .primary-controls button {
            padding: 12px 16px;
            font-size: 16px;
            font-weight: 700;
            min-height: 44px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        /* Secondary controls container - for less frequently used actions */
        .secondary-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }

        .secondary-button-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 6px;
            align-items: center;
        }

        .secondary-button-row select {
            padding: 8px 10px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            min-height: 36px;
            text-align: center;
        }

        .secondary-controls button {
            padding: 8px 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 36px;
            background-color: #6c757d;
            opacity: 0.85;
        }

        .secondary-controls button:hover {
            background-color: #5a6268;
            opacity: 1;
        }

        .board-size-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .board-size-controls label {
            font-weight: 500;
            font-size: 14px;
            color: #666;
        }

        .board-size-controls select {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: white;
            min-width: 100px;
            min-height: 36px;
        }

        button {
            padding: 15px 20px;
            margin: 0;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            /* Improve touch targets */
            min-height: 48px;
            min-width: 120px;
            /* Prevent button text selection */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Add touch feedback */
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            background-color: #3d8b40;
        }

        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            background-color: #cccccc;
            transform: none;
        }

        .status {
            flex-shrink: 0;
            padding: 8px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            width: 100%;
            text-align: center;
            font-size: 14px;
        }

        .error {
            color: #e53e3e;
            font-weight: bold;
        }

        .info {
            color: #333;
        }

        #current-player {
            font-size: 14px;
            font-weight: bold;
            margin: 4px 0;
            color: #2d3748;
        }

        #score-display {
            display: flex;
            justify-content: space-around;
            margin-top: 6px;
            flex-wrap: wrap;
            gap: 8px;
        }

        #score-display div {
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            min-width: 100px;
            text-align: center;
        }

        /* Mobile and tablet optimizations */
        @media (max-width: 768px) {
            .container {
                padding: 20px 3px 3px 3px;
                gap: 3px;
            }

            .game-area {
                margin-top: 10px;
            }

            .canvas-container {
                max-width: min(92vmin, 95vw);
                max-height: min(92vmin, 95vw);
            }

            .primary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 40px;
            }

            .secondary-controls {
                padding: 6px;
                gap: 4px;
            }

            .secondary-controls button {
                padding: 6px 8px;
                font-size: 12px;
                min-height: 32px;
            }

            .board-size-controls select {
                min-width: 70px;
                min-height: 28px;
                font-size: 11px;
            }

            .status {
                padding: 6px;
                font-size: 12px;
            }

            #current-player {
                font-size: 12px;
                margin: 2px 0;
            }

            #score-display div {
                padding: 3px 6px;
                font-size: 11px;
                min-width: 80px;
            }
        }

        /* Extra small mobile devices */
        @media (max-width: 480px) {
            .container {
                padding: 15px 2px 2px 2px;
                gap: 2px;
            }

            .game-area {
                margin-top: 8px;
            }

            .primary-controls {
                gap: 4px;
            }

            .primary-controls button {
                padding: 8px 10px;
                font-size: 13px;
                min-height: 36px;
            }

            .secondary-controls {
                padding: 4px;
                gap: 3px;
            }

            .secondary-button-row {
                grid-template-columns: 1fr;
                gap: 3px;
            }

            .secondary-controls button {
                padding: 5px 6px;
                font-size: 11px;
                min-height: 28px;
            }

            .status {
                padding: 4px;
                font-size: 11px;
            }

            #score-display {
                flex-direction: column;
                gap: 4px;
            }
        }

        /* Wide screen layout (desktop/landscape tablets) - side-by-side layout */
        @media (min-aspect-ratio: 4/3) and (min-width: 768px) {
            .container {
                flex-direction: row;
                padding: 8px;
                gap: 16px;
            }

            .game-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }

            .canvas-container {
                width: 100%;
                height: 100%;
                max-width: min(85vh, calc(100vw - 250px));
                max-height: min(85vh, calc(100vw - 250px));
            }

            .controls {
                flex-shrink: 0;
                width: auto;
                min-width: 220px;
                max-width: 400px;
                max-height: none;
                margin-top: 40px;
                gap: 12px;
                display: flex;
                flex-direction: column;
                overflow-y: auto;
                padding: 8px;
            }

            .primary-controls {
                gap: 12px;
            }

            .primary-controls button {
                padding: 14px 18px;
                font-size: 16px;
                min-height: 48px;
                min-width: auto;
                width: 100%;
                white-space: nowrap;
            }

            .secondary-controls {
                padding: 12px;
                gap: 8px;
            }

            .secondary-controls button {
                padding: 10px 12px;
                font-size: 14px;
                min-height: 38px;
                min-width: auto;
                white-space: nowrap;
            }

            .secondary-button-row {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                gap: 8px;
                align-items: center;
            }

            .secondary-button-row select {
                padding: 10px 12px;
                font-size: 14px;
                border: 1px solid #ccc;
                border-radius: 4px;
                background-color: white;
                min-height: 38px;
            }

            .secondary-button-row button {
                flex: 1;
            }

            .status {
                display: block;
                padding: 10px;
                font-size: 14px;
            }

            #current-player {
                font-size: 15px;
                margin: 6px 0;
            }

            #score-display {
                flex-direction: row;
                gap: 10px;
            }

            #score-display div {
                padding: 6px 10px;
                font-size: 13px;
                min-width: 120px;
            }
        }

        /* Mobile landscape (smaller screens) - compact horizontal layout */
        @media (max-height: 600px) and (orientation: landscape) and (max-width: 767px) {
            .container {
                flex-direction: row;
                padding: 3px;
                gap: 8px;
            }

            .game-area {
                flex: 1;
            }

            .controls {
                flex-shrink: 0;
                width: 200px;
                max-height: none;
                margin-top: 8px;
            }

            .status {
                display: none;
                /* Hide status in mobile landscape to save space */
            }

            .game-status {
                display: none;
                /* Hide game status in mobile landscape to save space */
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="game-canvas" width="600" height="600"></canvas>
            </div>
            <!-- Compact game status directly under the board -->
            <div class="game-status">
                <div id="current-player">Current Player: Black</div>
                <div id="score-display">
                    <div>Black Captures: <span id="black-score">0</span></div>
                    <div>White Captures: <span id="white-score">0</span></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <!-- Primary game controls - most frequently used -->
            <div class="primary-controls">
                <button id="undo-btn" disabled>Undo</button>
                <button id="redo-btn" disabled>Redo</button>
                <button id="pass-btn">Pass</button>
            </div>

            <!-- Secondary controls - less frequently used -->
            <div class="secondary-controls">
                <div class="secondary-button-row">
                    <button id="new-game-btn">New Game</button>
                    <select id="board-size">
                        <option value="9">9×9</option>
                        <option value="13">13×13</option>
                        <option value="19" selected>19×19</option>
                    </select>
                    <button id="copy-url-btn">Copy URL</button>
                </div>
            </div>

            <!-- Status display for messages only -->
            <div class="status">
                <div id="status-text" class="info">Loading...</div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { GoGame } from './pkg/rugo.js';

        let game = null;
        const canvas = document.getElementById('game-canvas');
        const statusText = document.getElementById('status-text');
        const currentPlayerText = document.getElementById('current-player');
        let suppressUrlUpdate = false; // Flag to prevent infinite loops
        let eventListenersSetup = false; // Flag to prevent duplicate event listeners

        async function initGame() {
            try {
                statusText.textContent = "Initializing Go Game...";
                statusText.className = "info";

                // Initialize the wasm module
                await init();

                statusText.textContent = "Creating game instance...";

                // Get selected board size
                const boardSize = parseInt(document.getElementById('board-size').value);

                // Set up responsive canvas sizing
                setupResponsiveCanvas();

                // Create game instance with selected size
                game = GoGame.new_with_size(canvas, boardSize);

                statusText.textContent = `Go Game Ready! (${boardSize}×${boardSize})`;

                // Set up event listeners (only once)
                if (!eventListenersSetup) {
                    setupEventListeners();
                }

                // Try to load state from URL, otherwise draw fresh board
                if (!loadStateFromUrl()) {
                    updateUrl(); // Set initial state in URL
                }
                drawBoard();
                updateUndoRedoButtons();

            } catch (error) {
                console.error('Failed to initialize game:', error);
                statusText.textContent = `Error: ${error}`;
                statusText.className = "error";
            }
        }

        function setupResponsiveCanvas() {
            const container = document.querySelector('.canvas-container');
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, rect.height);

            // Set canvas internal dimensions to a fixed size for consistent rendering
            canvas.width = 600;
            canvas.height = 600;

            // Scale the canvas using CSS to fit the container
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
        }

        function setupEventListeners() {
            if (eventListenersSetup) return; // Prevent duplicate listeners
            eventListenersSetup = true;

            // Helper function to handle board interactions
            function handleBoardInteraction(event) {
                if (!game) return;

                // Prevent default touch behaviors
                event.preventDefault();

                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                // Handle both touch and mouse events
                if (event.type === 'touchstart' || event.type === 'touchend') {
                    if (event.touches && event.touches.length > 0) {
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                    } else if (event.changedTouches && event.changedTouches.length > 0) {
                        clientX = event.changedTouches[0].clientX;
                        clientY = event.changedTouches[0].clientY;
                    } else {
                        return;
                    }
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                // Calculate coordinates relative to the displayed canvas size
                const canvasX = (clientX - rect.left) * (canvas.width / rect.width);
                const canvasY = (clientY - rect.top) * (canvas.height / rect.height);

                // Get current board size
                const currentBoardSize = game.get_board_size();

                // Calculate board layout (same as in drawBoard)
                const width = canvas.width;
                const height = canvas.height;
                const cellSize = Math.min(width, height) / (currentBoardSize + 1);
                const boardPixelSize = cellSize * (currentBoardSize - 1);
                const offsetX = (width - boardPixelSize) / 2;
                const offsetY = (height - boardPixelSize) / 2;

                // Convert canvas coordinates to board coordinates
                const boardX = Math.round((canvasX - offsetX) / cellSize);
                const boardY = Math.round((canvasY - offsetY) / cellSize);

                // Check if click is within board bounds
                if (boardX >= 0 && boardX < currentBoardSize && boardY >= 0 && boardY < currentBoardSize) {
                    try {
                        const result = game.handle_board_click(boardX, boardY);
                        if (result === "Move successful") {
                            drawBoard();
                            updateUndoRedoButtons();
                            updateUrl();
                            clearErrorMessage();
                        } else {
                            // Display error message to user
                            showErrorMessage(result);
                        }
                    } catch (error) {
                        console.error('Board interaction error:', error);
                        showErrorMessage('Error processing move: ' + error);
                    }
                }
            }

            // Canvas click handler
            canvas.addEventListener('click', handleBoardInteraction);

            // Touch event handlers for better mobile support
            canvas.addEventListener('touchstart', (event) => {
                // Store the touch for potential tap detection
                canvas._touchStartTime = Date.now();
                canvas._touchStartPos = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            });

            canvas.addEventListener('touchend', (event) => {
                // Only treat as tap if it was quick and didn't move much
                if (canvas._touchStartTime && canvas._touchStartPos) {
                    const touchDuration = Date.now() - canvas._touchStartTime;
                    const touch = event.changedTouches[0];
                    const deltaX = Math.abs(touch.clientX - canvas._touchStartPos.x);
                    const deltaY = Math.abs(touch.clientY - canvas._touchStartPos.y);

                    // Consider it a tap if it was quick and didn't move much
                    if (touchDuration < 500 && deltaX < 10 && deltaY < 10) {
                        handleBoardInteraction(event);
                    }
                }

                // Clean up
                delete canvas._touchStartTime;
                delete canvas._touchStartPos;
            });

            // Prevent context menu on touch devices
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            // Board size selector
            document.getElementById('board-size').addEventListener('change', (event) => {
                // Ask for confirmation before changing board size (which resets the game)
                const confirmed = confirm('Changing the board size will start a new game and lose your current progress. Continue?');
                if (!confirmed) {
                    // Revert the selection to the current board size
                    const currentBoardSize = game ? game.get_board_size() : 19;
                    event.target.value = currentBoardSize.toString();
                    return;
                }

                // Clear URL state when user changes board size manually
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);
                initGame(); // Start new game with selected size
            });

            // New game button
            document.getElementById('new-game-btn').addEventListener('click', () => {
                // Ask for confirmation before starting a new game
                const confirmed = confirm('Start a new game? This will lose your current progress.');
                if (!confirmed) {
                    return;
                }

                // Clear URL state for fresh game
                const url = new URL(window.location);
                url.searchParams.delete('state');
                window.history.replaceState(null, '', url);

                // Start fresh game
                initGame();
            });

            // Undo button
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (game && game.undo()) {
                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Redo button
            document.getElementById('redo-btn').addEventListener('click', () => {
                if (game && game.redo()) {
                    drawBoard();
                    updateUndoRedoButtons();
                    updateUrl();
                }
            });

            // Pass button
            document.getElementById('pass-btn').addEventListener('click', () => {
                if (game) {
                    try {
                        const result = game.handle_pass();
                        if (result === "Pass successful") {
                            drawBoard();
                            updateUndoRedoButtons();
                            updateUrl();
                            clearErrorMessage();

                            // Show temporary pass message
                            const player = game.get_current_player() === 1 ? 'White' : 'Black'; // Previous player (who just passed)
                            const previousPlayer = game.get_current_player() === 1 ? 'Black' : 'White';
                            showErrorMessage(`${previousPlayer} passes. ${player}'s turn.`);
                            setTimeout(clearErrorMessage, 2000);
                        } else {
                            showErrorMessage(result);
                        }
                    } catch (error) {
                        console.error('Pass error:', error);
                        showErrorMessage('Error processing pass: ' + error);
                    }
                }
            });

            // Copy URL button
            document.getElementById('copy-url-btn').addEventListener('click', async () => {
                if (!game) {
                    showErrorMessage('No game to copy URL for');
                    return;
                }

                try {
                    // Ensure URL is up to date with current game state
                    updateUrl();

                    // Copy current URL to clipboard
                    await navigator.clipboard.writeText(window.location.href);

                    // Show success message
                    showErrorMessage('Game URL copied to clipboard!');
                    setTimeout(clearErrorMessage, 2000);
                } catch (error) {
                    console.error('Failed to copy URL:', error);
                    // Fallback for browsers that don't support clipboard API
                    try {
                        // Create a temporary input element
                        const tempInput = document.createElement('input');
                        tempInput.value = window.location.href;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);

                        showErrorMessage('Game URL copied to clipboard!');
                        setTimeout(clearErrorMessage, 2000);
                    } catch (fallbackError) {
                        console.error('Fallback copy failed:', fallbackError);
                        showErrorMessage('Failed to copy URL to clipboard');
                    }
                }
            });

            // Handle window resize and orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce resize events
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 100);
            });

            // Handle orientation change
            window.addEventListener('orientationchange', () => {
                // Wait a bit for the orientation to fully change
                setTimeout(() => {
                    if (game) {
                        setupResponsiveCanvas();
                        drawBoard();
                    }
                }, 250);
            });
        }

        function updateUndoRedoButtons() {
            if (!game) {
                document.getElementById('undo-btn').disabled = true;
                document.getElementById('redo-btn').disabled = true;
                return;
            }

            document.getElementById('undo-btn').disabled = !game.can_undo();
            document.getElementById('redo-btn').disabled = !game.can_redo();
        }

        // Update URL with current game state
        function updateUrl() {
            if (!game || suppressUrlUpdate) return;

            try {
                const state = game.serialize_state();
                const url = new URL(window.location);
                url.searchParams.set('state', state);
                window.history.replaceState(null, '', url);
            } catch (error) {
                console.warn('Failed to update URL:', error);
            }
        }

        // Load game state from URL
        function loadStateFromUrl() {
            const url = new URL(window.location);
            const stateParam = url.searchParams.get('state');

            if (stateParam && game) {
                suppressUrlUpdate = true;
                try {
                    if (game.deserialize_state(stateParam)) {
                        console.log('Successfully loaded state from URL');
                        // Update board size selector to match loaded state
                        const boardSize = game.get_board_size();
                        document.getElementById('board-size').value = boardSize.toString();
                        return true;
                    } else {
                        console.warn('Failed to deserialize state from URL');
                    }
                } catch (error) {
                    console.warn('Error loading state from URL:', error);
                } finally {
                    suppressUrlUpdate = false;
                }
            }
            return false;
        }

        // Handle browser back/forward navigation
        window.addEventListener('popstate', () => {
            if (game && loadStateFromUrl()) {
                drawBoard();
                updateUndoRedoButtons();
            }
        });

        function drawBoard() {
            if (!game) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Get current board size
            const currentBoardSize = game.get_board_size();

            // Clear canvas
            ctx.fillStyle = '#DEB887';
            ctx.fillRect(0, 0, width, height);

            // Draw grid lines
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            const cellSize = Math.min(width, height) / (currentBoardSize + 1);
            const boardPixelSize = cellSize * (currentBoardSize - 1);
            const offsetX = (width - boardPixelSize) / 2;
            const offsetY = (height - boardPixelSize) / 2;

            // Draw horizontal lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const y = offsetY + i * cellSize;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + boardPixelSize, y);
                ctx.stroke();
            }

            // Draw vertical lines (need boardSize lines for boardSize intersections)
            for (let i = 0; i < currentBoardSize; i++) {
                const x = offsetX + i * cellSize;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + boardPixelSize);
                ctx.stroke();
            }

            // Draw star points based on board size
            let starPoints = [];
            if (currentBoardSize === 19) {
                starPoints = [
                    [3, 3], [9, 3], [15, 3],
                    [3, 9], [9, 9], [15, 9],
                    [3, 15], [9, 15], [15, 15]
                ];
            } else if (currentBoardSize === 13) {
                starPoints = [
                    [3, 3], [3, 9], [9, 3], [9, 9], // corners
                    [6, 6] // center
                ];
            } else if (currentBoardSize === 9) {
                starPoints = [
                    [2, 2], [2, 6], [6, 2], [6, 6], // corners
                    [4, 4] // center
                ];
            }

            ctx.fillStyle = '#000';
            for (let [sx, sy] of starPoints) {
                const x = offsetX + sx * cellSize;
                const y = offsetY + sy * cellSize;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Draw stones
            for (let y = 0; y < currentBoardSize; y++) {
                for (let x = 0; x < currentBoardSize; x++) {
                    const state = game.get_board_state(x, y);
                    if (state !== 0) {
                        const centerX = offsetX + x * cellSize;
                        const centerY = offsetY + y * cellSize;
                        const radius = cellSize * 0.4;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);

                        if (state === 1) { // Black
                            ctx.fillStyle = '#000';
                        } else { // White
                            ctx.fillStyle = '#FFF';
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                        }

                        ctx.fill();
                        if (state === 2) {
                            ctx.stroke();
                        }
                    }
                }
            }

            // Update current player display
            const player = game.get_current_player();
            currentPlayerText.textContent = `Current Player: ${player === 1 ? 'Black' : 'White'}`;

            // Update capture scores
            document.getElementById('black-score').textContent = game.get_black_captures();
            document.getElementById('white-score').textContent = game.get_white_captures();
        }

        // Error message handling
        function showErrorMessage(message) {
            statusText.textContent = message;
            statusText.className = "error";

            // Clear error after 3 seconds
            setTimeout(() => {
                clearErrorMessage();
            }, 3000);
        }

        function clearErrorMessage() {
            const boardSize = game ? game.get_board_size() : 19;
            statusText.textContent = `Go Game Ready! (${boardSize}×${boardSize})`;
            statusText.className = "info";
        }

        // Start the game
        initGame();
    </script>
</body>

</html>
